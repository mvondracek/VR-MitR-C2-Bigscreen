<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <style>
        body {
          font-family: sans-serif;
        }
        video {
            max-width: 100%;
            border: 1px solid black;
        }
        #video > div {
            display: inline-block;
            max-width: 32%;
        }
    </style>
</head>
<body>
    <button id="btn_socket_connect">connect</button>
    <div id="videos"></div>




    <video id="remoteVideoDirect" autoplay playsinline controls></video>


<!-- This file is automatically added/served when running "node index.js". -->
<script src="./adapter-latest.js"></script>
<script src="./msgpack.min.js"></script>
<script>
'use strict';

const offerOptions = {
  offerToReceiveAudio: 1,
  offerToReceiveVideo: 1
};

function Connection(userId, scid, pcid){
    this.userId = userId;
    this.scid = scid;
    this.pcid = pcid;
    this.isStarted = false;
    this.isInitiator = false;
    this.rtcPeerConnection = null;
}
let connections = [];

let allRemoteStreams = [];

let turnReady;

let dataChannelSend, dataChannelReceive;

const pcConfig = {
    'iceServers': [{
        'urls': 'stun:stun.l.google.com:19302'
    }]
};

<!--region variables for Bigscreen signaling protocol-->
let NAME = 'Mallory1';
let roomId = 'room-';
let myUserId;
let myUuid = generateBigscreenUuid();
let unityVersion = '0.34.0';
let mySteamId = '';
let myOculusId = '';



<!--endregion-->

const bigscreenSignalUrl = 'wss://signal2.bigscreenvr.com';
let websocket;


<!--region GUI bindings -->
const remoteVideoDirect = document.querySelector('#remoteVideoDirect');
const btn_socket_connect = document.getElementById('btn_socket_connect');
const videosElement = document.getElementById('videos');
<!--endregion-->

function connect() {
    websocket = new WebSocket(bigscreenSignalUrl);
    websocket.binaryType = 'arraybuffer';
    websocket.onopen = function (event) {
        console.log('connected', event);
        sendMessage({type: 'register-desktop'});
        console.log('registered');
    };
    websocket.onclose = function (event) {
        console.log('onClose disconnected', event);
    };
    websocket.onmessage = function (event) {
        onMessage(event);
    };
    websocket.onerror = function (event) {
        console.log('onError event', event);
    };
}

btn_socket_connect.addEventListener("click", function () {
    connect();
});

////////////////////////////////////////////////

function sendMessage(message) {
    console.log('sendMessage', message);
    websocket.send(msgpack.encode(message));
}

function onMessage(event) {
    let message = msgpack.decode(new Uint8Array(event.data));
    console.log('onMessage', message);

    switch (message.type) {
        case "room-latest":
        case "admin":
        case "linkedpc-joined":
        case "linkedpc-left":
        case "party-join":
        case "user-ready":
        case "user-left":
        case "room-join-fail":
        case "room-created":
        case "room-environment":
        case "room-private":
        case "room-public":
        case "events":
        case "server-time":
            console.log('received message ignored', message);
            break;

        case "user-joined":
            if(message.uuid === myUuid){
                myUserId = message.userId;
                console.log('set myUserId', myUserId);
                sendUserReady();
                console.log('user ready');
            }
            break;

        case 'ice':
            console.log('onMessage received ICE');
            console.assert(message.fromDevice === 'desktop', message.fromDevice);

            const candidateStartPos = message.value.indexOf('candidate:');
            let beforeCandidate  = message.value.slice(0,candidateStartPos);
            let sdpMLineIndex = beforeCandidate.slice(0, beforeCandidate.indexOf('bigscreen_sdp_mline_index'));
            let sdpMid = beforeCandidate.slice(
                beforeCandidate.indexOf('bigscreen_sdp_mline_index') + 'bigscreen_sdp_mline_index'.length,
                beforeCandidate.indexOf('bigscreen_sdp_mid'));
            let candidate = new RTCIceCandidate({
                sdpMid: sdpMid,
                sdpMLineIndex: sdpMLineIndex,
                candidate: message.value.slice(candidateStartPos)
            });
            {
                let connection = connections.find(function(c){return c.userId === message.fromUser && c.pcid === message.PCID});
                console.log('ice conn', connection);
                connection.rtcPeerConnection.addIceCandidate(candidate);
            }
            break;
        case 'offer':
            console.log('onMessage received OFFER');
            console.assert(message.fromDevice === 'desktop', message.fromDevice);

            {
                let connection = new Connection(message.fromUser, message.SCID, message.PCID);
                connections.push(connection);

                if (!connection.isInitiator && !connection.isStarted) {
                    maybeStart(connection);
                }
                connection.rtcPeerConnection.setRemoteDescription(new RTCSessionDescription(
                    {type: message.type, sdp: message.value, SCID: connection.scid, pcid: connection.pcid}));
                doAnswer(connection);
            }
            break;
        case 'answer':
            console.error('onMessage received ANSWER');

            console.assert(message.roomId === roomId, message.roomId, roomId);
            console.assert(message.targetUser === myUserId, message.targetUser, myUserId);
            console.assert(message.fromDevice === 'desktop', message.fromDevice);
            console.assert(message.targetDevice === 'desktop', message.targetDevice);
            {
                let connection = connections.find(function(c){return c.userId === message.fromUser && c.pcid === message.PCID});
                if (connection.isStarted) {
                    connection.setRemoteDescription(new RTCSessionDescription(
                        {
                            type: message.type,
                            sdp: message.value,
                            scid: connection.scid,
                            pcid: connection.pcid
                        }));
                }
            }
            break;
        default:
            console.error('Unexpected message type (server to client):', message);
            break;
    }
}

function generateBigscreenUuid() {
  function bigscreenRand() {
    return Math["floor"]((1 + Math["random"]()) * 65536).toString(16) ["substring"](1)
  }
  return bigscreenRand() + bigscreenRand() + "-" + bigscreenRand() + "-" + bigscreenRand() + "-" + bigscreenRand() + "-" + bigscreenRand() + bigscreenRand() + bigscreenRand()
}

function joinRoom(){
    sendMessage({
        'type': "room-join",
        'roomId': roomId,
        'name': NAME,
        'uuid': myUuid,
        'version': unityVersion,
        'steamId': mySteamId,
        'oculusId': myOculusId
    });
}

function sendUserReady(){
    sendMessage({
        type: "user-ready",
        roomId: roomId,
        userId: myUserId
    })
}
////////////////////////////////////////////////////

if (location.hostname !== 'localhost') {
    requestTurn(
        'https://computeengineondemand.appspot.com/turn?username=41784574&key=4080218913'
    );
}

function maybeStart(connection) {
    if (!connection.isStarted) {
        try {
            connection.rtcPeerConnection = new RTCPeerConnection(null);
            connection.rtcPeerConnection.onicecandidate = function (event) {
                console.log('icecandidate event: ', event);
                if (event.candidate) {
                    sendMessage({
                        type: 'ice',
                        roomId: roomId,
                        value: event.candidate.sdpMLineIndex + 'bigscreen_sdp_mline_index'
                            + event.candidate.sdpMid + 'bigscreen_sdp_mid' + event.candidate.candidate,
                        fromDevice: 'desktop',
                        targetDevice: 'desktop',
                        fromUser: myUserId,
                        targetUser: connection.userId,
                        SCID: connection.scid,
                        PCID: connection.pcid,
                    });
                } else {
                    console.log('End of candidates.');
                }
            };
            connection.rtcPeerConnection.ontrack  = function (event) {
                console.log('Remote streams added.');
                console.log(event.streams);
                allRemoteStreams.push(event.streams);
                connection.remoteStream = event.streams[0];
                if(connection.pcid === 0){

                    let video = document.createElement("video");
                    video.setAttribute('autoplay','');
                    video.setAttribute('playsinline','');
                    video.setAttribute('controls','');
                    video.srcObject = event.streams[0];
                    videosElement.appendChild(video);
                }
            };
            connection.rtcPeerConnection.onremovestream = function (event) {
                console.log('Remote stream removed. Event: ', event);
            };

            console.log('Created RTCPeerConnnection');
        } catch (e) {
            console.log('Failed to create PeerConnection, exception: ' + e.message);
            alert('Cannot create RTCPeerConnection object.');
            return;
        }
        if (connection.isInitiator){
            dataChannelSend = connection.rtcPeerConnection.createDataChannel('__FOOBAR_DATA_CHANNEL_NAME_DIRECT__');
            dataChannelSend.onopen = onSendChannelStateChangeDirect;
            dataChannelSend.onclose = onSendChannelStateChangeDirect;
        }
        else{
            connection.rtcPeerConnection.ondatachannel = function(event) {
                console.log('Receive Channel Callback');
                dataChannelReceive = event.channel;
                dataChannelReceive.onmessage = function(event){
                    console.error('Received Message', connection, event.data);
                };
                dataChannelReceive.onopen = onReceiveChannelStateChangeDirect;
                dataChannelReceive.onclose = onReceiveChannelStateChangeDirect;
            };
        }

        connection.isStarted = true;
        console.log('connection.isInitiator', connection.isInitiator);
        if (connection.isInitiator) {
            console.log('Sending offer to peer');
            connection.rtcPeerConnection.createOffer(offerOptions).then(
                function(sdp){setLocalAndSendMessage(sdp, connection)}, handleCreateOfferError);
        }
    }
}

function onSendChannelStateChangeDirect() {
  const readyState = dataChannelSend.readyState;
  console.log('dataChannelSend Send channel state is: ' + readyState);
}
function onReceiveChannelStateChangeDirect() {
  const readyState = dataChannelReceive.readyState;
  console.log(`receiveDataChannelDirect Receive channel state is: ${readyState}`);
}

/////////////////////////////////////////////////////////




function handleCreateOfferError(event) {
    console.log('createOffer() error: ', event);
}

function setLocalAndSendMessage(sessionDescription, connection) {
    connection.rtcPeerConnection.setLocalDescription(sessionDescription);
    let sessionDescriptionMessage = {
        type: sessionDescription.type,
        roomId: roomId,
        value: sessionDescription.sdp,
        fromDevice: 'desktop',
        targetDevice: 'desktop',
        fromUser: myUserId,
        targetUser: connection.userId,
        SCID: connection.scid,
        PCID: connection.pcid,
    };
    console.log('setLocalAndSendMessage sending message', sessionDescriptionMessage);
    sendMessage(sessionDescriptionMessage);
}

function doAnswer(connection) {
    console.log('Sending answer to peer.');
    connection.rtcPeerConnection.createAnswer().then(
        function(sdp){setLocalAndSendMessage(sdp, connection)},
        onCreateSessionDescriptionError
    );
}

function onCreateSessionDescriptionError(error) {
    console.log('Failed to create session description: ' + error.toString());
}

function requestTurn(turnURL) {
    let turnExists = false;
    for (let i in pcConfig.iceServers) {
        if (pcConfig.iceServers[i].urls.substr(0, 5) === 'turn:') {
            turnExists = true;
            turnReady = true;
            break;
        }
    }
    if (!turnExists) {
        console.log('Getting TURN server from ', turnURL);
        // No TURN server. Get one from computeengineondemand.appspot.com:
        let xhr = new XMLHttpRequest();
        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4 && xhr.status === 200) {
                let turnServer = JSON.parse(xhr.responseText);
                console.log('Got TURN server: ', turnServer);
                pcConfig.iceServers.push({
                    'urls': 'turn:' + turnServer.username + '@' + turnServer.turn,
                    'credential': turnServer.password
                });
                turnReady = true;
            }
        };
        xhr.open('GET', turnURL, true);
        xhr.send();
    }
}

</script>
</body>
</html>
