<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <style>
body {
  font-family: sans-serif;
}

video {
    max-width: 100%;
    width: 320px;
    border: 1px solid black;
}
    </style>
</head>
<body>
    <button id="btn_setLocalStream">setLocalStream</button>
    <button id="btn_socket_connect">connect</button>
    <button id="btn_socket_close">close both sockets</button>
    <button id="btn_hangup">hangup both</button>

    <div id="videos">
        <video id="localVideo" autoplay muted playsinline></video>
        <video id="remoteVideoBigscreen" autoplay playsinline></video>
        <video id="remoteVideoDirect" autoplay playsinline></video>
    </div>

<!-- This file is automatically added/served when running "node index.js". -->
<script src="./adapter-latest.js"></script>
<script src="./msgpack.min.js"></script>
<script>
'use strict';
let isInitiator = false;
let isStarted = false;
let isStartedDirect = false;
let localStream;
let peerConnectionBigscreen;
let peerConnectionDirect;

let remoteStreamBigscreen;
let remoteStreamDirect;

let allRemoteStreams = [];

let turnReady;

let sendDataChannelBigscreen, receiveDataChannelBigscreen;
let sendDataChannelDirect, receiveDataChannelDirect;

const pcConfig = {
    'iceServers': [{
        'urls': 'stun:stun.l.google.com:19302'
    }]
};

// bigscreen variables
let roomId = null;
let SCID = null;
let PCID = null;
let userIdBehindServer = null;
let userIdDirect = null;

function checkRoomId(value){
    if (roomId === null){
        roomId = value;
        console.log('RoomId set', roomId);
    }
    else if(roomId !== value){
        console.error('Error: Different roomId already set.', roomId, value);
    }
}
function checkSCID(value){
    if (SCID === null){
        SCID = value;
        console.log('SCID set', SCID);
    }
    else if(SCID !== value){
        console.error('Error: Different SCID already set.', SCID, value);
    }
}
function checkPCID(value){
    if (PCID === null){
        PCID = value;
        console.log('PCID set', PCID);
    }
    else if(PCID !== value){
        console.error('Error: Different PCID already set. BUT WILL CHANGE NOW!', PCID, value);
        PCID = value;
        console.log('PCID set', PCID);
    }
}
function checkUserIdBehindServer(value){
    if (userIdBehindServer === null){
        userIdBehindServer = value;
        console.log('userIdBehindServer set', userIdBehindServer);
    }
    else if(userIdBehindServer !== value){
        console.error('Error: Different userIdBehindServer already set.', userIdBehindServer, value);
    }
}
function checkUserIdDirect(value){
    if (userIdDirect === null){
        userIdDirect = value;
        console.log('userIdDirect set', userIdDirect);
    }
    else if(userIdDirect !== value){
        console.error('Error: Different userIdDirect already set.', userIdDirect, value);
    }
}
// //

/////////////////////////////////////////////
const wsUri = "ws://172.26.104.1:8090/";
const bigscreenSignalUrl = 'wss://signal2.bigscreenvr.com';
let websocketDirect;
let websocketBigscreen;


<!--region GUI bindings -->
const localVideo = document.querySelector('#localVideo');
const remoteVideoBigscreen = document.querySelector('#remoteVideoBigscreen');
const remoteVideoDirect = document.querySelector('#remoteVideoDirect');

const btn_socket_close = document.getElementById('btn_socket_close');
const btn_socket_connect = document.getElementById('btn_socket_connect');
const btn_hangup = document.getElementById('btn_hangup');
const btn_setLocalStream = document.getElementById('btn_setLocalStream');
<!--endregion-->

function connectDirect() {
    websocketDirect = new WebSocket(wsUri);
    websocketDirect.binaryType = 'arraybuffer';
    websocketDirect.onopen = function (event) {
        console.log('onOpen connected', event);
    };
    websocketDirect.onclose = function (event) {
        console.log('onClose disconnected', event);
    };
    websocketDirect.onmessage = function (event) {
        onMessageDirect(event);
    };
    websocketDirect.onerror = function (event) {
        console.log('onError event', event);
    };

    btn_socket_close.addEventListener("click", function () {
        websocketDirect.close();
    });
}

function connectBigscreen() {
    websocketBigscreen = new WebSocket(bigscreenSignalUrl);
    websocketBigscreen.binaryType = 'arraybuffer';
    websocketBigscreen.onopen = function (event) {
        console.log('websocketBigscreen.onOpen', event);
    };
    websocketBigscreen.onclose = function (event) {
        console.log('websocketBigscreen.onClose', event);
    };
    websocketBigscreen.onmessage = function (event) {
        onMessageBigscreen(event);
    };
    websocketBigscreen.onerror = function (event) {
        console.log('websocketBigscreen.onError', event);
    };

    btn_socket_close.addEventListener("click", function () {
        websocketBigscreen.close();
    });
}

btn_socket_connect.addEventListener("click", function () {
    connectDirect();
    connectBigscreen();
});
btn_hangup.addEventListener("click", function () {
    console.log('Hanging up.');
    stop();
    sendMessageDirect('bye');
});

btn_setLocalStream.addEventListener("click", function setLocalStream(){
    navigator.mediaDevices.getUserMedia({
        audio: true,
        video: true
    })
    .then(function (stream) {
        console.log('setLocalStream');
        localStream = stream;
        localVideo.srcObject = stream;
    })
    .catch(function (e) {
        alert('getUserMedia() error: ' + e.name);
    });
});



////////////////////////////////////////////////

function sendMessageDirect(message) {
    console.log('MITM -> Client ', message);
    websocketDirect.send(msgpack.encode(message));
}

function sendMessageBigscreen(message) {
    console.log('MITM -> Bigscreen', message);
    websocketBigscreen.send(msgpack.encode(message));
}

function onMessageBigscreen(event){
    let message = msgpack.decode(new Uint8Array(event.data));
    console.log('Bigscreen -> MITM', message);

    // server to client forwarding rules
    switch (message.type) {
        case 'room-latest':
        case 'admin':
            // server to client content not useful
            sendMessageDirect(message); // forward to the client
            break;
        case 'room-created':
            checkRoomId(message.roomId);
            sendMessageDirect(message); // forward to the client
            break;
        case 'user-joined':
            checkRoomId(message.state.roomId);
            sendMessageDirect(message); // forward to the client
            break;
        case 'user-ready':
            checkRoomId(message.state.roomId);
            sendMessageDirect(message); // forward to the client
            break;
        case 'user-left':
            checkRoomId(message.state.roomId);
            sendMessageDirect(message); // forward to the client
            break;

        case 'ice':
            console.log('onMessageBigscreen received ICE');
            checkRoomId(message.roomId);
            checkSCID(message.SCID);
            checkPCID(message.PCID);
            checkUserIdBehindServer(message.fromUser);
            checkUserIdDirect(message.targetUser);

            const candidateStartPos = message.value.indexOf('candidate:');
            let beforeCandidate  = message.value.slice(0,candidateStartPos);
            let sdpMLineIndex = beforeCandidate.slice(0, beforeCandidate.indexOf('bigscreen_sdp_mline_index'));
            let sdpMid = beforeCandidate.slice(
                beforeCandidate.indexOf('bigscreen_sdp_mline_index') + 'bigscreen_sdp_mline_index'.length,
                beforeCandidate.indexOf('bigscreen_sdp_mid'));
            let candidate = new RTCIceCandidate({
                sdpMid: sdpMid,
                sdpMLineIndex: sdpMLineIndex,
                candidate: message.value.slice(candidateStartPos)
            });
            peerConnectionBigscreen.addIceCandidate(candidate);
            break;

        case 'offer':
            console.log('onMessageBigscreen received OFFER');
            checkRoomId(message.roomId);
            checkSCID(message.SCID);
            checkPCID(message.PCID);
            checkUserIdBehindServer(message.fromUser);
            checkUserIdDirect(message.targetUser);

            if (!isInitiator && !isStarted) {
                maybeStartBigscreen();
            }
            peerConnectionBigscreen.setRemoteDescription(new RTCSessionDescription(
                {type:message.type, sdp:message.value}));
            doAnswerBigscreen();
            break;
        case 'answer':
            console.log('onMessageBigscreen received ANSWER');
            checkUserIdBehindServer(message.fromUser);
            checkSCID(message.SCID);
            checkPCID(message.PCID);

            if(isStarted) {
                peerConnectionBigscreen.setRemoteDescription(new RTCSessionDescription(
                    {type:message.type, sdp:message.value}));
            }
            break;

        default:
            console.log('Unexpected message type (server to client):', message);
            break;
    }
}

function onMessageDirect(event) {
    let message = msgpack.decode(new Uint8Array(event.data));
    console.log('Client -> MITM', message);

    // client to server forwarding rules
    switch (message.type) {
        case 'room-latest':
        case 'register-desktop':
        case 'room-leave':
        case 'room-create':
            // client to server content not useful
            sendMessageBigscreen(message); // forward to the server
            break;

        case 'room-join':
            checkRoomId(message.roomId);
            sendMessageBigscreen(message); // forward to the server
            break;

        case 'admin':
            checkRoomId(message.roomId);
            sendMessageBigscreen(message); // forward to the server
            break;

        case 'user-seat':
            checkUserIdDirect(message.userId);
            checkRoomId(message.roomId);
            sendMessageBigscreen(message); // forward to the server
            break;

        case 'user-ready':
            checkUserIdDirect(message.userId);
            checkRoomId(message.roomId);
            sendMessageBigscreen(message); // forward to the server
            break;

        case 'ice':
            console.log('onMessageDirect received ICE');
            checkRoomId(message.roomId);
            checkUserIdBehindServer(message.targetUser);
            checkUserIdDirect(message.fromUser);
            checkSCID(message.SCID);
            checkPCID(message.PCID);

            const candidateStartPos = message.value.indexOf('candidate:');
            let beforeCandidate  = message.value.slice(0,candidateStartPos);
            let sdpMLineIndex = beforeCandidate.slice(0, beforeCandidate.indexOf('bigscreen_sdp_mline_index'));
            let sdpMid = beforeCandidate.slice(
                beforeCandidate.indexOf('bigscreen_sdp_mline_index') + 'bigscreen_sdp_mline_index'.length,
                beforeCandidate.indexOf('bigscreen_sdp_mid'));
            let candidate = new RTCIceCandidate({
                sdpMid: sdpMid,
                sdpMLineIndex: sdpMLineIndex,
                candidate: message.value.slice(candidateStartPos)
            });
            peerConnectionDirect.addIceCandidate(candidate);
            break;

        case 'offer':
            console.log('onMessageDirect received OFFER');
            checkRoomId(message.roomId);
            checkUserIdBehindServer(message.targetUser);
            checkUserIdDirect(message.fromUser);
            checkSCID(message.SCID);
            checkPCID(message.PCID);

            if (!isInitiator && !isStartedDirect) {
                maybeStartDirect();
            }
            peerConnectionDirect.setRemoteDescription(new RTCSessionDescription(
                {type:message.type, sdp:message.value}));
            doAnswerDirect();
            break;
        case 'answer':
            console.log('onMessageDirect received ANSWER');
            checkRoomId(message.roomId);
            checkUserIdBehindServer(message.targetUser);
            checkUserIdDirect(message.fromUser);
            checkSCID(message.SCID);
            checkPCID(message.PCID);

            if(isStartedDirect) {
                peerConnectionDirect.setRemoteDescription(new RTCSessionDescription(
                    {type:message.type, sdp:message.value}));
            }
            break;

        default:
            console.log('onMessageDirect Unexpected message type (client to server):', message);
            break;
    }
}

////////////////////////////////////////////////////

if (location.hostname !== 'localhost') {
    requestTurn(
        'https://computeengineondemand.appspot.com/turn?username=41784574&key=4080218913'
    );
}

function maybeStartDirect() {
    if (!isStarted && typeof localStream !== 'undefined') {
        try {
            peerConnectionDirect = new RTCPeerConnection(null);
            peerConnectionDirect.onicecandidate = function (event) {
                console.log('icecandidate event: ', event);
                if (event.candidate) {
                    console.log('maybeStartDirect',event.candidate.sdpMLineIndex, event.candidate.sdpMid);
                    if(SCID === null){console.error('ERROR: SCID IS NULL')}
                    sendMessageDirect({
                        type: 'ice',
                        roomId: roomId,
                        value: event.candidate.sdpMLineIndex + 'bigscreen_sdp_mline_index'
                            + event.candidate.sdpMid + 'bigscreen_sdp_mid' + event.candidate.candidate,
                        fromDevice: 'desktop',
                        targetDevice: 'desktop',
                        fromUser: userIdBehindServer,
                        targetUser: userIdDirect,
                        SCID: SCID,
                        PCID: PCID,
                    });
                } else {
                    console.log('End of candidates.');
                }
            };
            peerConnectionDirect.ontrack  = function (event) {
                console.log('Remote streams added.');
                console.log(event.streams);
                allRemoteStreams.push(event.streams);
                remoteStreamDirect = event.streams[0];
                remoteVideoDirect.srcObject = remoteStreamDirect;
            };
            peerConnectionDirect.onremovestream = function (event) {
                console.log('Remote stream removed. Event: ', event);
            };

            console.log('Created RTCPeerConnnection');
        } catch (e) {
            console.log('Failed to create PeerConnection, exception: ' + e.message);
            alert('Cannot create RTCPeerConnection object.');
            return;
        }
        if (isInitiator){
            sendDataChannelDirect = peerConnectionDirect.createDataChannel('__FOOBAR_DATA_CHANNEL_NAME_DIRECT__');
            sendDataChannelDirect.onopen = onSendChannelStateChangeDirect;
            sendDataChannelDirect.onclose = onSendChannelStateChangeDirect;
        }
        else{
            peerConnectionDirect.ondatachannel = function(event) {
                console.log('Receive Channel Callback');
                receiveDataChannelDirect = event.channel;
                receiveDataChannelDirect.onmessage = function(event){
                    console.log('Received Message', event.data);
                };
                receiveDataChannelDirect.onopen = onReceiveChannelStateChangeDirect;
                receiveDataChannelDirect.onclose = onReceiveChannelStateChangeDirect;
            };
        }

        peerConnectionDirect.addStream(localStream);
        isStarted = true;
        console.log('isInitiator', isInitiator);
        if (isInitiator) {
            console.log('Sending offer to peer');
            peerConnectionDirect.createOffer(setLocalAndSendMessageDirect, handleCreateOfferError);
        }
    }
}

function maybeStartBigscreen() {
    if (!isStarted && typeof localStream !== 'undefined') {
        try {
            peerConnectionBigscreen = new RTCPeerConnection(null);
            peerConnectionBigscreen.onicecandidate = function (event) {
                console.log('peerConnectionBigscreen icecandidate event: ', event);
                if (event.candidate) {
                    console.log('maybeStartDirect',event.candidate.sdpMLineIndex, event.candidate.sdpMid);
                    if(SCID === null){console.error('ERROR: SCID IS NULL')}
                    sendMessageBigscreen({
                        type: 'ice',
                        roomId: roomId,
                        value: event.candidate.sdpMLineIndex + 'bigscreen_sdp_mline_index'
                            + event.candidate.sdpMid + 'bigscreen_sdp_mid' + event.candidate.candidate,                        fromDevice: 'desktop',
                        targetDevice: 'desktop',
                        fromUser: userIdDirect,
                        targetUser: userIdBehindServer,
                        SCID: SCID,
                        PCID: PCID,
                    });
                } else {
                    console.log('End of candidates.');
                }
            };
            peerConnectionBigscreen.ontrack  = function (event) {
                console.log('Remote streams added.');
                console.log(event.streams);
                allRemoteStreams.push(event.streams);
                remoteStreamBigscreen = event.streams[0];
                remoteVideoBigscreen.srcObject = remoteStreamBigscreen;
            };
            peerConnectionBigscreen.onremovestream = function (event) {
                console.log('Remote stream removed. Event: ', event);
            };

            console.log('Created RTCPeerConnnection');
        } catch (e) {
            console.log('Failed to create PeerConnection, exception: ' + e.message);
            alert('Cannot create RTCPeerConnection object.');
            return;
        }
        if (isInitiator){
            sendDataChannelBigscreen = peerConnectionBigscreen.createDataChannel('__FOOBAR_DATA_CHANNEL_NAME_DIRECT__');
            sendDataChannelBigscreen.onopen = onSendChannelStateChangeBigscreen;
            sendDataChannelBigscreen.onclose = onSendChannelStateChangeBigscreen;
        }
        else{
            peerConnectionBigscreen.ondatachannel = function(event) {
                console.log('Receive Channel Callback');
                receiveDataChannelBigscreen = event.channel;
                receiveDataChannelBigscreen.onmessage = function(event){
                    console.log('Received Message', event.data);
                };
                receiveDataChannelBigscreen.onopen = onReceiveChannelStateChangeBigscreen;
                receiveDataChannelBigscreen.onclose = onReceiveChannelStateChangeBigscreen;
            };
        }

        peerConnectionBigscreen.addStream(localStream);
        isStarted = true;
        console.log('isInitiator', isInitiator);
        if (isInitiator) {
            console.log('Sending offer to peer');
            peerConnectionBigscreen.createOffer(setLocalAndSendMessageBigscreen(), handleCreateOfferError);
        }
    }
}

function onSendChannelStateChangeBigscreen() {
  const readyState = sendDataChannelBigscreen.readyState;
  console.log('sendDataChannelBigscreen Send channel state is: ' + readyState);
}
function onSendChannelStateChangeDirect() {
  const readyState = sendDataChannelDirect.readyState;
  console.log('sendDataChannelDirect Send channel state is: ' + readyState);
}

function onReceiveChannelStateChangeBigscreen() {
  const readyState = receiveDataChannelBigscreen.readyState;
  console.log(`receiveDataChannelBigscreen Receive channel state is: ${readyState}`);
}
function onReceiveChannelStateChangeDirect() {
  const readyState = receiveDataChannelDirect.readyState;
  console.log(`receiveDataChannelDirect Receive channel state is: ${readyState}`);
}

/////////////////////////////////////////////////////////




function handleCreateOfferError(event) {
    console.log('createOffer() error: ', event);
}

function setLocalAndSendMessageDirect(sessionDescription) {
    peerConnectionDirect.setLocalDescription(sessionDescription);
    let sessionDescriptionMessage = {
        type: sessionDescription.type,
        roomId: roomId,
        value: sessionDescription.sdp,
        fromDevice: 'desktop',
        targetDevice: 'desktop',
        fromUser: userIdBehindServer,
        targetUser: userIdDirect,
        SCID: SCID,
        PCID: PCID,
    };
    console.log('setLocalAndSendMessageDirect sending message', sessionDescriptionMessage);
    sendMessageDirect(sessionDescriptionMessage);
}

function setLocalAndSendMessageBigscreen(sessionDescription) {
    peerConnectionBigscreen.setLocalDescription(sessionDescription);
    let sessionDescriptionMessage = {
        type: sessionDescription.type,
        roomId: roomId,
        value: sessionDescription.sdp,
        fromDevice: 'desktop',
        targetDevice: 'desktop',
        fromUser: userIdDirect,
        targetUser: userIdBehindServer,
        SCID: SCID,
        PCID: PCID,
    };
    console.log('setLocalAndSendMessageBigscreen sending message', sessionDescriptionMessage);
    sendMessageBigscreen(sessionDescriptionMessage);
}


function doAnswerDirect() {
    console.log('Sending answer to peer.');
    peerConnectionDirect.createAnswer().then(
        setLocalAndSendMessageDirect,
        onCreateSessionDescriptionError
    );
}

function doAnswerBigscreen() {
    console.log('doAnswerBigscreen Sending answer to peer.');
    peerConnectionBigscreen.createAnswer().then(
        setLocalAndSendMessageBigscreen,
        onCreateSessionDescriptionError
    );
}


function onCreateSessionDescriptionError(error) {
    console.log('Failed to create session description: ' + error.toString());
}

function requestTurn(turnURL) {
    let turnExists = false;
    for (let i in pcConfig.iceServers) {
        if (pcConfig.iceServers[i].urls.substr(0, 5) === 'turn:') {
            turnExists = true;
            turnReady = true;
            break;
        }
    }
    if (!turnExists) {
        console.log('Getting TURN server from ', turnURL);
        // No TURN server. Get one from computeengineondemand.appspot.com:
        let xhr = new XMLHttpRequest();
        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4 && xhr.status === 200) {
                let turnServer = JSON.parse(xhr.responseText);
                console.log('Got TURN server: ', turnServer);
                pcConfig.iceServers.push({
                    'urls': 'turn:' + turnServer.username + '@' + turnServer.turn,
                    'credential': turnServer.password
                });
                turnReady = true;
            }
        };
        xhr.open('GET', turnURL, true);
        xhr.send();
    }
}


function stop() {
    isStarted = false;
    peerConnectionBigscreen.close();
    peerConnectionBigscreen = null;
    peerConnectionDirect.close();
    peerConnectionDirect = null;
}
</script>
</body>
</html>
