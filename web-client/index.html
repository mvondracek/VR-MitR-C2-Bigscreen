<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <style>
        body {
          font-family: sans-serif;
        }
        video {
            max-width: 100%;
            border: 1px solid black;
        }
        #video > div {
            display: inline-block;
            max-width: 32%;
        }
    </style>
</head>
<body>
    <button id="btn_socket_connect">connect</button>
    <video id="remoteVideoDirect" autoplay playsinline controls></video>


<!-- This file is automatically added/served when running "node index.js". -->
<script src="./adapter-latest.js"></script>
<script src="./msgpack.min.js"></script>
<script>
'use strict';
let isInitiator = false;
let isStarted = [false, false];

const offerOptions = {
  offerToReceiveAudio: 1,
  offerToReceiveVideo: 1
};

let remoteStream;

let allRemoteStreams = [];

let turnReady;

let dataChannelSend, dataChannelReceive;

const pcConfig = {
    'iceServers': [{
        'urls': 'stun:stun.l.google.com:19302'
    }]
};

<!--region variables for Bigscreen signaling protocol-->
let SCIDLookup = [];
let globSCID;
let PCLookup = [];

let NAME = 'Mallory1';
let roomId = 'room-';
let myUserId;
let myUuid = generateBigscreenUuid();
let unityVersion = '0.34.0';
let mySteamId = '';
let myOculusId = '';



<!--endregion-->

const bigscreenSignalUrl = 'wss://signal2.bigscreenvr.com';
let websocket;


<!--region GUI bindings -->
const remoteVideoDirect = document.querySelector('#remoteVideoDirect');
const btn_socket_connect = document.getElementById('btn_socket_connect');
<!--endregion-->

function connect() {
    websocket = new WebSocket(bigscreenSignalUrl);
    websocket.binaryType = 'arraybuffer';
    websocket.onopen = function (event) {
        console.log('connected', event);
        sendMessage({type: 'register-desktop'});
        console.log('registered');
    };
    websocket.onclose = function (event) {
        console.log('onClose disconnected', event);
    };
    websocket.onmessage = function (event) {
        onMessage(event);
    };
    websocket.onerror = function (event) {
        console.log('onError event', event);
    };
}

btn_socket_connect.addEventListener("click", function () {
    connect();
});

////////////////////////////////////////////////

function sendMessage(message) {
    console.log('sendMessage', message);
    websocket.send(msgpack.encode(message));
}

function onMessage(event) {
    let message = msgpack.decode(new Uint8Array(event.data));
    console.log('onMessage', message);

    switch (message.type) {
        case "room-latest":
        case "admin":
        case "linkedpc-joined":
        case "linkedpc-left":
        case "party-join":
        case "user-ready":
        case "user-left":
        case "room-join-fail":
        case "room-created":
        case "room-environment":
        case "room-private":
        case "room-public":
        case "events":
        case "server-time":
            console.log('received message ignored', message);
            break;

        case "user-joined":
            if(message.uuid === myUuid){
                myUserId = message.userId;
                console.log('set myUserId', myUserId);
                sendUserReady();
                console.log('user ready');
            }
            break;

        case 'ice':
            console.log('onMessage received ICE');
            console.assert(message.fromDevice === 'desktop', message.fromDevice);
            SCIDLookup[message.SCID] = message.fromUser;
            globSCID = message.SCID; // todo

            const candidateStartPos = message.value.indexOf('candidate:');
            let beforeCandidate  = message.value.slice(0,candidateStartPos);
            let sdpMLineIndex = beforeCandidate.slice(0, beforeCandidate.indexOf('bigscreen_sdp_mline_index'));
            let sdpMid = beforeCandidate.slice(
                beforeCandidate.indexOf('bigscreen_sdp_mline_index') + 'bigscreen_sdp_mline_index'.length,
                beforeCandidate.indexOf('bigscreen_sdp_mid'));
            let candidate = new RTCIceCandidate({
                sdpMid: sdpMid,
                sdpMLineIndex: sdpMLineIndex,
                candidate: message.value.slice(candidateStartPos)
            });
            PCLookup[message.PCID].addIceCandidate(candidate);
            break;
        case 'offer':
            console.log('onMessage received OFFER');
            console.assert(message.fromDevice === 'desktop', message.fromDevice);
            SCIDLookup[message.SCID] = message.fromUser;
            globSCID = message.SCID; // todo

            if (!isInitiator && !isStarted[message.PCID]) {
                maybeStart(globSCID, message.PCID);
            }
            PCLookup[message.PCID].setRemoteDescription(new RTCSessionDescription(
                {type:message.type, sdp:message.value, SCID:globSCID, pcid:message.PCID}));
            doAnswer(message.PCID);
            break;
        case 'answer':
            console.error('onMessage received ANSWER');

            console.assert(message.roomId === roomId, message.roomId, roomId);
            console.assert(message.targetUser === myUserId, message.targetUser, myUserId);
            console.assert(message.fromDevice === 'desktop', message.fromDevice);
            console.assert(message.targetDevice === 'desktop', message.targetDevice);
            SCIDLookup[message.SCID] = message.fromUser;
            globSCID = message.SCID; // todo

            if(isStarted[message.PCID]) {
                PCLookup[message.PCID].setRemoteDescription(new RTCSessionDescription(
                    {type:message.type, sdp:message.value, scid:globSCID, pcid:message.PCID}));
            }
            break;
        default:
            console.error('Unexpected message type (server to client):', message);
            break;
    }
}

function generateBigscreenUuid() {
  function bigscreenRand() {
    return Math["floor"]((1 + Math["random"]()) * 65536).toString(16) ["substring"](1)
  }
  return bigscreenRand() + bigscreenRand() + "-" + bigscreenRand() + "-" + bigscreenRand() + "-" + bigscreenRand() + "-" + bigscreenRand() + bigscreenRand() + bigscreenRand()
}

function joinRoom(){
    sendMessage({
        'type': "room-join",
        'roomId': roomId,
        'name': NAME,
        'uuid': myUuid,
        'version': unityVersion,
        'steamId': mySteamId,
        'oculusId': myOculusId
    });
}

function sendUserReady(){
    sendMessage({
        type: "user-ready",
        roomId: roomId,
        userId: myUserId
    })
}
////////////////////////////////////////////////////

if (location.hostname !== 'localhost') {
    requestTurn(
        'https://computeengineondemand.appspot.com/turn?username=41784574&key=4080218913'
    );
}

function maybeStart(SCID, PCID) {
    if (!isStarted[PCID]) {
        try {
            PCLookup[PCID] = new RTCPeerConnection(null);
            PCLookup[PCID].onicecandidate = function (event) {
                console.log('icecandidate event: ', event);
                if (event.candidate) {
                    console.log('maybeStart',event.candidate.sdpMLineIndex, event.candidate.sdpMid);
                    if(SCID === null){console.error('ERROR: SCID IS NULL')}
                    sendMessage({
                        type: 'ice',
                        roomId: roomId,
                        value: event.candidate.sdpMLineIndex + 'bigscreen_sdp_mline_index'
                            + event.candidate.sdpMid + 'bigscreen_sdp_mid' + event.candidate.candidate,
                        fromDevice: 'desktop',
                        targetDevice: 'desktop',
                        fromUser: myUserId,
                        targetUser: SCIDLookup[SCID],
                        SCID: SCID,
                        PCID: PCID,
                    });
                } else {
                    console.log('End of candidates.');
                }
            };
            PCLookup[PCID].ontrack  = function (event) {
                console.log('Remote streams added.');
                console.log(event.streams);
                allRemoteStreams.push(event.streams);
                remoteStream = event.streams[0];
                remoteVideoDirect.srcObject = remoteStream;
            };
            PCLookup[PCID].onremovestream = function (event) {
                console.log('Remote stream removed. Event: ', event);
            };

            console.log('Created RTCPeerConnnection');
        } catch (e) {
            console.log('Failed to create PeerConnection, exception: ' + e.message);
            alert('Cannot create RTCPeerConnection object.');
            return;
        }
        if (isInitiator){
            dataChannelSend = PCLookup[PCID].createDataChannel('__FOOBAR_DATA_CHANNEL_NAME_DIRECT__');
            dataChannelSend.onopen = onSendChannelStateChangeDirect;
            dataChannelSend.onclose = onSendChannelStateChangeDirect;
        }
        else{
            PCLookup[PCID].ondatachannel = function(event) {
                console.log('Receive Channel Callback');
                dataChannelReceive = event.channel;
                dataChannelReceive.onmessage = function(event){
                    console.error('Received Message', event.data);
                };
                dataChannelReceive.onopen = onReceiveChannelStateChangeDirect;
                dataChannelReceive.onclose = onReceiveChannelStateChangeDirect;
            };
        }

        isStarted[PCID] = true;
        console.log('isInitiator', isInitiator);
        if (isInitiator) {
            console.log('Sending offer to peer');
            PCLookup[PCID].createOffer(offerOptions).then(setLocalAndSendMessage, handleCreateOfferError);
        }
    }
}

function onSendChannelStateChangeDirect() {
  const readyState = dataChannelSend.readyState;
  console.log('dataChannelSend Send channel state is: ' + readyState);
}
function onReceiveChannelStateChangeDirect() {
  const readyState = dataChannelReceive.readyState;
  console.log(`receiveDataChannelDirect Receive channel state is: ${readyState}`);
}

/////////////////////////////////////////////////////////




function handleCreateOfferError(event) {
    console.log('createOffer() error: ', event);
}

function setLocalAndSendMessage(sessionDescription,pcid) {
    PCLookup[pcid].setLocalDescription(sessionDescription);
    let sessionDescriptionMessage = {
        type: sessionDescription.type,
        roomId: roomId,
        value: sessionDescription.sdp,
        fromDevice: 'desktop',
        targetDevice: 'desktop',
        fromUser: myUserId,
        targetUser: SCIDLookup[globSCID],
        SCID: globSCID,
        PCID: pcid,
    };
    console.log('setLocalAndSendMessage sending message', sessionDescriptionMessage);
    sendMessage(sessionDescriptionMessage);
}

function doAnswer(pcid) {
    console.log('Sending answer to peer.');
    PCLookup[pcid].createAnswer().then(
        function(sdp){
        setLocalAndSendMessage(sdp, pcid)},
        onCreateSessionDescriptionError
    );
}

function onCreateSessionDescriptionError(error) {
    console.log('Failed to create session description: ' + error.toString());
}

function requestTurn(turnURL) {
    let turnExists = false;
    for (let i in pcConfig.iceServers) {
        if (pcConfig.iceServers[i].urls.substr(0, 5) === 'turn:') {
            turnExists = true;
            turnReady = true;
            break;
        }
    }
    if (!turnExists) {
        console.log('Getting TURN server from ', turnURL);
        // No TURN server. Get one from computeengineondemand.appspot.com:
        let xhr = new XMLHttpRequest();
        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4 && xhr.status === 200) {
                let turnServer = JSON.parse(xhr.responseText);
                console.log('Got TURN server: ', turnServer);
                pcConfig.iceServers.push({
                    'urls': 'turn:' + turnServer.username + '@' + turnServer.turn,
                    'credential': turnServer.password
                });
                turnReady = true;
            }
        };
        xhr.open('GET', turnURL, true);
        xhr.send();
    }
}

</script>
</body>
</html>
